<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daniel's Anti-Notion FloatNote</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Elastic overscroll */
    .notes-editor,
    .checklist-items,
    .dashboard,
    .habit-grid,
    .habit-manage-scroll {
      overscroll-behavior-y: contain;
    }
    .bounce-out { transition: transform 0.1s ease-out; }
    .bounce-back { transition: transform 0.2s cubic-bezier(.2,.8,.4,1); }

    :root {
      --bg-deep: #0f0f1a;
      --bg-surface: #1e1e32;
      --bg-overlay: #252540;
      --bg-card: rgba(255, 255, 255, 0.04);
      --bg-card-hover: rgba(255, 255, 255, 0.07);
      --text-primary: #e2e4f0;
      --text-secondary: #8b8da8;
      --text-muted: #5a5c74;
      --accent: #b48eff;
      --accent-glow: rgba(180, 142, 255, 0.25);
      --blue: #5b9cf5;
      --green: #6dd4a0;
      --red: #f06292;
      --yellow: #ffd180;
      --border: rgba(255, 255, 255, 0.06);
      --border-light: rgba(255, 255, 255, 0.1);
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg-deep);
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Single ambient glow - lightweight */
    body::before {
      content: '';
      position: fixed;
      top: -40%; left: -20%;
      width: 80%; height: 80%;
      background: radial-gradient(ellipse, var(--accent-glow) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    /* Onboarding overlay */
    .onboarding-overlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: var(--bg-deep);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      -webkit-app-region: drag;
    }
    .onboarding-overlay.hidden { display: none; }
    .onboarding-card {
      -webkit-app-region: no-drag;
      width: 320px;
      text-align: center;
    }
    .onboarding-card h1 {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 6px;
    }
    .onboarding-card p {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 22px;
    }
    .onboarding-field {
      margin-bottom: 14px;
      text-align: left;
    }
    .onboarding-field label {
      display: block;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }
    .onboarding-field input,
    .onboarding-field select {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-surface);
      border: 1px solid var(--border-light);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s;
    }
    .onboarding-field input:focus,
    .onboarding-field select:focus {
      border-color: var(--accent);
    }
    .onboarding-field select option {
      background: var(--bg-surface);
      color: var(--text-primary);
    }
    .onboarding-btn {
      width: 100%;
      padding: 11px;
      margin-top: 8px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
      font-family: inherit;
    }
    .onboarding-btn:hover { opacity: 0.85; }
    .onboarding-error {
      color: var(--red);
      font-size: 11px;
      margin-top: 6px;
      min-height: 16px;
    }

    /* Title bar */
    .titlebar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 15, 26, 0.95);
      padding: 8px 14px;
      -webkit-app-region: drag;
      user-select: none;
      flex-shrink: 0;
      border-bottom: 1px solid var(--border);
      position: relative;
      z-index: 10;
    }
    .titlebar-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: linear-gradient(135deg, var(--accent), var(--blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
    }
    .titlebar-buttons { display: flex; gap: 8px; -webkit-app-region: no-drag; }
    .titlebar-btn {
      width: 13px; height: 13px; border-radius: 50%; border: none; cursor: pointer;
      transition: transform 0.15s; opacity: 0.8;
    }
    .titlebar-btn:hover { opacity: 1; transform: scale(1.15); }
    .btn-minimize { background: var(--yellow); }
    .btn-close { background: var(--red); }

    /* Tabs */
    .tabs {
      display: flex;
      background: rgba(15, 15, 26, 0.9);
      flex-shrink: 0;
      padding: 0 8px;
      gap: 2px;
      border-bottom: 1px solid var(--border);
      position: relative;
      z-index: 10;
    }
    .tab {
      flex: 1; padding: 10px 8px; text-align: center; font-size: 11px; font-weight: 600;
      cursor: pointer; border-bottom: 2px solid transparent; color: var(--text-muted);
      transition: color 0.2s, border-color 0.2s; letter-spacing: 0.3px;
    }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    .tab:hover:not(.active) { color: var(--text-secondary); }

    /* Category toggle */
    .category-bar {
      display: flex; background: rgba(15, 15, 26, 0.6); flex-shrink: 0;
      padding: 8px 14px; gap: 8px; position: relative; z-index: 10;
    }
    .cat-btn {
      flex: 1; padding: 7px; text-align: center; font-size: 11px; font-weight: 600;
      border: 1px solid var(--border-light); border-radius: 8px; background: transparent;
      color: var(--text-muted); cursor: pointer; transition: background 0.2s, color 0.2s, border-color 0.2s; letter-spacing: 0.3px;
    }
    .cat-btn:hover { background: var(--bg-card-hover); color: var(--text-secondary); }
    .cat-btn.active-pro {
      background: rgba(91, 156, 245, 0.15);
      color: var(--blue); border-color: rgba(91, 156, 245, 0.3);
    }
    .cat-btn.active-per {
      background: rgba(109, 212, 160, 0.15);
      color: var(--green); border-color: rgba(109, 212, 160, 0.3);
    }

    /* Panels */
    .panel {
      flex: 1; display: none; flex-direction: column; overflow: hidden;
      position: relative; z-index: 5;
    }
    .panel.active { display: flex; }

    /* Notes */
    .notes-editor {
      flex: 1; background: transparent; color: var(--text-primary); border: none; padding: 16px;
      font-family: 'Segoe UI', system-ui, sans-serif; font-size: 13.5px; line-height: 1.7;
      outline: none; letter-spacing: 0.2px; overflow-y: auto;
      word-wrap: break-word;
    }
    .notes-editor:empty::before {
      content: 'Start typing... (Ctrl+B bold, Ctrl+I italic, Ctrl+L bullet, # heading)';
      color: var(--text-muted); font-style: italic; pointer-events: none;
    }
    .notes-editor .note-heading {
      display: block; font-size: 15.5px; font-weight: 700; color: var(--accent);
      border-bottom: 1px solid rgba(180, 142, 255, 0.2); padding-bottom: 4px;
      margin: 12px 0 6px 0; letter-spacing: 0.4px; position: relative;
    }
    .notes-editor .note-heading:first-child { margin-top: 0; }
    .notes-editor .note-bullet {
      display: block; padding-left: 28px; min-height: 1.7em; position: relative;
    }
    .notes-editor .note-bullet::before {
      content: '\2022'; position: absolute; left: 10px; color: var(--text-secondary); font-size: 15px;
    }

    /* Inline formatting inside editor */
    .notes-editor b, .notes-editor strong { font-weight: 700; }
    .notes-editor i, .notes-editor em { font-style: italic; }
    .notes-editor u { text-decoration: underline; text-underline-offset: 2px; }
    .notes-editor s, .notes-editor strike { text-decoration: line-through; color: var(--text-muted); }

    /* Title heading (# ) */
    .notes-editor .note-title {
      display: block; font-size: 20px; font-weight: 700; color: var(--text-primary);
      margin: 12px 0 6px 0; letter-spacing: 0.3px; position: relative;
    }
    .notes-editor .note-title:first-child { margin-top: 0; }

    /* Subheading (### ) */
    .notes-editor .note-subheading {
      display: block; font-size: 14px; font-weight: 600; color: var(--text-secondary);
      margin: 10px 0 4px 0; letter-spacing: 0.3px; position: relative;
    }
    .notes-editor .note-subheading:first-child { margin-top: 0; }

    /* Section delete button (shared by heading, title, subheading) */
    .notes-editor .section-delete {
      position: absolute; right: 4px; top: 50%; transform: translateY(-50%);
      background: none; border: none; color: var(--text-muted); cursor: pointer;
      font-size: 14px; line-height: 1; padding: 2px 5px; border-radius: 3px;
      opacity: 0; transition: opacity 0.15s, color 0.15s;
    }
    .notes-editor .note-heading:hover .section-delete,
    .notes-editor .note-title:hover .section-delete,
    .notes-editor .note-subheading:hover .section-delete { opacity: 1; }
    .notes-editor .section-delete:hover { color: var(--red); }

    /* Numbered list */
    .notes-editor .note-numbered {
      display: block; padding-left: 28px; min-height: 1.7em; position: relative;
    }
    .notes-editor .note-numbered::before {
      content: attr(data-num) '.'; position: absolute; left: 8px; color: var(--text-secondary);
      font-size: 13px; font-weight: 600;
    }

    /* Checklist inside notes editor */
    .notes-editor .note-checklist {
      display: flex; align-items: flex-start; gap: 8px; min-height: 1.7em; padding: 1px 0;
    }
    .notes-editor .note-checklist .check-box {
      appearance: none; -webkit-appearance: none;
      width: 16px; height: 16px; border: 2px solid var(--text-muted);
      border-radius: 4px; cursor: pointer; flex-shrink: 0;
      margin-top: 3px; transition: background 0.15s, border-color 0.15s; background: transparent;
    }
    .notes-editor .note-checklist .check-box:checked {
      background: var(--accent); border-color: var(--accent);
    }
    .notes-editor .note-checklist .check-box:checked::after {
      content: ''; position: absolute; left: 4px; top: 1px;
      width: 5px; height: 9px; border: solid white; border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    .notes-editor .note-checklist .check-box { position: relative; }
    .notes-editor .note-checklist .check-text {
      flex: 1; outline: none; min-width: 0;
    }
    .notes-editor .note-checklist.checked .check-text {
      text-decoration: line-through; color: var(--text-muted);
    }

    /* Indent levels */
    .notes-editor .indent-1 { margin-left: 28px; }
    .notes-editor .indent-2 { margin-left: 56px; }
    .notes-editor .indent-3 { margin-left: 84px; }

    /* Inline code */
    .notes-editor code {
      font-family: 'Cascadia Code', 'Consolas', 'Courier New', monospace;
      background: rgba(180, 142, 255, 0.1); color: var(--accent);
      padding: 1px 5px; border-radius: 4px; font-size: 12.5px;
    }

    /* Checklist */
    .checklist-items { flex: 1; overflow-y: auto; padding: 8px 14px; }

    .inline-input {
      display: flex; align-items: center; gap: 10px; padding: 8px 8px; margin-top: 4px;
    }
    .inline-input .bullet {
      width: 16px; height: 16px; border: 2px solid var(--text-muted); border-radius: 4px;
      flex-shrink: 0; opacity: 0.5;
    }
    .inline-input input {
      flex: 1; background: transparent; border: none;
      border-bottom: 1px solid var(--border-light);
      color: var(--text-primary); font-size: 13px; padding: 6px 0; outline: none;
      font-family: 'Segoe UI', system-ui, sans-serif; transition: border-color 0.2s;
    }
    .inline-input input:focus { border-bottom-color: var(--accent); }
    .inline-input input::placeholder { color: var(--text-muted); font-style: italic; }

    .checklist-item {
      display: flex; align-items: center; gap: 10px; padding: 9px 8px;
      border-radius: 8px; transition: background 0.15s; border: 1px solid transparent;
      position: relative;
    }
    .checklist-item:hover {
      background: var(--bg-card-hover); border-color: var(--border);
    }
    .checklist-item input[type="checkbox"] {
      appearance: none; -webkit-appearance: none;
      width: 17px; height: 17px; border: 2px solid var(--text-muted);
      border-radius: 4px; cursor: pointer; flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s; position: relative; background: transparent;
    }
    .checklist-item input[type="checkbox"]:checked {
      background: var(--accent); border-color: var(--accent);
    }
    .checklist-item input[type="checkbox"]:checked::after {
      content: '';
      position: absolute; left: 4px; top: 1px;
      width: 5px; height: 9px;
      border: solid white; border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    .checklist-item .item-text { flex: 1; font-size: 13px; cursor: default; }
    .checklist-item.checked .item-text { text-decoration: line-through; color: var(--text-muted); }
    .checklist-item .delete-btn {
      background: none; border: none; color: var(--text-muted); cursor: pointer;
      font-size: 16px; padding: 0 4px; opacity: 0; transition: opacity 0.15s;
    }
    .checklist-item:hover .delete-btn { opacity: 1; }
    .checklist-item .delete-btn:hover { color: var(--red); }

    /* Priority border accent */
    .checklist-item.priority-high { border-left-color: var(--red) !important; }
    .checklist-item.priority-medium { border-left-color: var(--yellow) !important; }
    .checklist-item.priority-low { border-left-color: var(--blue) !important; }

    /* Priority flag button */
    .priority-btn {
      background: none; border: none; cursor: pointer;
      font-size: 12px; padding: 0 2px; flex-shrink: 0;
      color: var(--text-muted); opacity: 0.2; transition: opacity 0.15s, color 0.15s;
      line-height: 1; font-family: inherit;
    }
    .checklist-item:hover .priority-btn { opacity: 0.6; }
    .priority-btn.p-high { color: var(--red); opacity: 1 !important; }
    .priority-btn.p-medium { color: var(--yellow); opacity: 1 !important; }
    .priority-btn.p-low { color: var(--blue); opacity: 1 !important; }

    /* Date badge (shown on hover) */
    .item-date-badge {
      font-size: 9.5px; color: var(--text-muted); opacity: 0;
      transition: opacity 0.15s; white-space: nowrap; flex-shrink: 0;
      letter-spacing: 0.2px;
    }
    .checklist-item:hover .item-date-badge { opacity: 0.65; }

    /* Clean list toolbar */
    .checklist-toolbar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 4px 14px 0; flex-shrink: 0;
    }
    .clean-btn {
      padding: 3px 10px; font-size: 10px; font-weight: 600; letter-spacing: 0.3px;
      border: 1px solid var(--border-light); border-radius: 6px; background: transparent;
      color: var(--text-muted); cursor: pointer; transition: background 0.15s, color 0.15s, border-color 0.15s; font-family: inherit;
    }
    .clean-btn:hover {
      color: var(--red); border-color: rgba(240, 98, 146, 0.4);
      background: rgba(240, 98, 146, 0.08);
    }

    /* Sort select */
    .sort-select {
      padding: 3px 8px; font-size: 10px; font-weight: 600; letter-spacing: 0.3px;
      border: 1px solid var(--border-light); border-radius: 6px;
      background: transparent; color: var(--text-muted); cursor: pointer;
      transition: color 0.15s; font-family: inherit; outline: none;
      appearance: none; -webkit-appearance: none;
    }
    .sort-select:hover { color: var(--text-secondary); }
    .sort-select option { background: var(--bg-surface); color: var(--text-primary); }

    /* Deadline button */
    .deadline-btn {
      background: none; border: none; cursor: pointer;
      font-size: 11px; padding: 0 2px; flex-shrink: 0;
      opacity: 0; transition: opacity 0.15s; line-height: 1; font-family: inherit;
      color: var(--text-muted);
    }
    .checklist-item:hover .deadline-btn { opacity: 0.5; }
    .deadline-btn.has-deadline { opacity: 1 !important; color: var(--yellow); }
    .deadline-btn.overdue { opacity: 1 !important; color: var(--red); }

    /* Deadline badge */
    .deadline-badge {
      font-size: 9.5px; white-space: nowrap; flex-shrink: 0; letter-spacing: 0.2px;
      padding: 1px 5px; border-radius: 4px;
      background: rgba(255, 209, 128, 0.1); color: var(--yellow);
      border: 1px solid rgba(255, 209, 128, 0.2);
    }
    .deadline-badge.overdue {
      background: rgba(240, 98, 146, 0.1); color: var(--red);
      border-color: rgba(240, 98, 146, 0.25);
    }

    /* Dashboard */
    .dashboard { flex: 1; overflow-y: auto; padding: 14px; }

    /* Stoic Quote */
    .quote-card {
      background: linear-gradient(135deg, color-mix(in srgb, var(--accent) 8%, transparent), rgba(91, 156, 245, 0.05));
      border: 1px solid color-mix(in srgb, var(--accent) 12%, transparent);
      border-radius: 12px;
      padding: 16px 18px;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .quote-card:hover { border-color: color-mix(in srgb, var(--accent) 25%, transparent); }
    .quote-card::before {
      content: '\201C';
      position: absolute;
      top: -4px; left: 10px;
      font-size: 52px;
      font-family: Georgia, 'Times New Roman', serif;
      color: color-mix(in srgb, var(--accent) 12%, transparent);
      pointer-events: none;
      line-height: 1;
    }
    .quote-text {
      font-family: Georgia, 'Times New Roman', serif;
      font-style: italic;
      font-size: 13.5px;
      line-height: 1.6;
      color: var(--text-primary);
      margin-bottom: 8px;
      padding-left: 4px;
      transition: opacity 0.35s;
    }
    .quote-text.fading { opacity: 0; }
    .quote-author {
      font-size: 10.5px;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: 0.8px;
      text-transform: uppercase;
      text-align: right;
      transition: opacity 0.35s;
    }
    .quote-author.fading { opacity: 0; }
    .quote-hint {
      position: absolute;
      bottom: 6px; left: 18px;
      font-size: 9px;
      color: var(--text-muted);
      opacity: 0;
      transition: opacity 0.2s;
    }
    .quote-card:hover .quote-hint { opacity: 1; }

    /* Stats */
    .stat-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      text-align: center;
      transition: background 0.2s, border-color 0.2s, transform 0.2s;
      position: relative;
      overflow: hidden;
    }
    .stat-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 2px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .stat-card:hover::before { opacity: 1; }
    .stat-card:hover {
      background: var(--bg-card-hover);
      border-color: var(--border-light);
      transform: translateY(-1px);
    }
    .stat-card::before { background: linear-gradient(90deg, transparent, var(--accent), transparent); }
    .stat-icon { font-size: 18px; margin-bottom: 2px; }
    .stat-value {
      font-size: 26px; font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #d4a8ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      line-height: 1.2;
    }
    .stat-label {
      font-size: 10px; color: var(--text-muted); margin-top: 3px;
      text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;
    }
    .stat-value.blue {
      background: linear-gradient(135deg, var(--blue), #82b5f7);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .stat-value.green {
      background: linear-gradient(135deg, var(--green), #9ae8c0);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .stat-value.yellow {
      background: linear-gradient(135deg, var(--yellow), #ffe0a0);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }

    /* Chart */
    .chart-container {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .chart-title {
      font-size: 11px; font-weight: 600; color: var(--text-secondary);
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .chart-toggle {
      display: flex; gap: 4px;
    }
    .chart-toggle-btn {
      padding: 3px 10px;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.3px;
      border: 1px solid var(--border-light);
      border-radius: 6px;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
      font-family: inherit;
    }
    .chart-toggle-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .chart-toggle-btn:hover:not(.active) {
      color: var(--text-secondary);
      background: var(--bg-card-hover);
    }
    canvas { width: 100% !important; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 5px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--bg-overlay); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    ::selection { background: var(--accent-glow); color: white; }

    /* === Habit Tracker === */

    /* Sub-tab active states */
    .cat-btn.active-habit {
      background: rgba(180, 142, 255, 0.15);
      color: var(--accent); border-color: rgba(180, 142, 255, 0.3);
    }
    .cat-btn.active-manage {
      background: rgba(91, 156, 245, 0.15);
      color: var(--blue); border-color: rgba(91, 156, 245, 0.3);
    }

    /* Sub-panels */
    .habit-subpanel { display: none; flex-direction: column; flex: 1; overflow: hidden; }
    .habit-subpanel.active { display: flex; }

    /* Week navigation */
    .habit-week-nav {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 14px; flex-shrink: 0;
    }
    .habit-week-nav button {
      background: transparent; border: 1px solid var(--border-light); border-radius: 6px;
      color: var(--text-secondary); cursor: pointer; padding: 4px 10px; font-size: 11px;
      font-weight: 600; font-family: inherit; transition: background 0.15s, color 0.15s;
    }
    .habit-week-nav button:hover:not(:disabled) {
      background: var(--bg-card-hover); color: var(--text-primary);
    }
    .habit-week-nav button:disabled { opacity: 0.3; cursor: default; }
    .habit-week-label {
      font-size: 11px; font-weight: 600; color: var(--text-secondary);
      letter-spacing: 0.3px;
    }

    /* Habit grid (Notion-style) */
    .habit-grid { flex: 1; overflow-y: auto; padding: 0 14px 10px; }

    .habit-grid-table {
      width: 100%; border-collapse: collapse;
    }
    .habit-grid-table th {
      font-size: 10px; font-weight: 600; color: var(--text-muted);
      text-transform: uppercase; letter-spacing: 0.5px; padding: 6px 0;
      text-align: center; width: 36px;
    }
    .habit-grid-table th:first-child {
      text-align: left; width: auto; padding-left: 4px;
    }
    .habit-grid-table th.today-col { color: var(--accent); }
    .habit-grid-table td.today { background: rgba(180, 142, 255, 0.06); }

    .habit-grid-table td {
      padding: 5px 0; text-align: center; vertical-align: middle;
    }
    .habit-grid-table td:first-child {
      text-align: left; padding-left: 4px;
      font-size: 12px; color: var(--text-primary); font-weight: 500;
      max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }

    .habit-grid-table tr {
      border-bottom: 1px solid var(--border);
    }
    .habit-grid-table tr:last-child { border-bottom: none; }

    /* Habit cell (checkbox circle) */
    .habit-cell {
      width: 26px; height: 26px; border-radius: 50%; display: inline-flex;
      align-items: center; justify-content: center; cursor: pointer;
      border: 2px solid var(--border-light); transition: background 0.15s, border-color 0.15s, color 0.15s;
      font-size: 11px; color: transparent; background: transparent;
    }
    .habit-cell:hover:not(.disabled) {
      border-color: var(--accent); background: rgba(180, 142, 255, 0.08);
    }
    .habit-cell.checked {
      background: var(--accent); border-color: var(--accent); color: #fff;
      animation: habit-pop 0.2s ease-out;
    }
    @keyframes habit-pop {
      0% { transform: scale(0.6); }
      50% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    /* Draggable habit cells */
    .habit-cell[draggable="true"] { cursor: grab; }
    .habit-cell[draggable="true"]:active { cursor: grabbing; }

    .habit-drop-target {
      width: 26px; height: 26px; border-radius: 50%; display: inline-flex;
      align-items: center; justify-content: center;
      border: 2px dashed transparent; transition: border-color 0.15s, background 0.15s;
    }
    .habit-drop-target.drag-over {
      border-color: var(--accent); background: rgba(180, 142, 255, 0.08);
    }

    /* Empty state */
    .habit-empty {
      text-align: center; padding: 40px 20px; color: var(--text-muted);
      font-size: 13px; font-style: italic;
    }
    .habit-empty-hint {
      font-size: 11px; margin-top: 8px; color: var(--text-muted); opacity: 0.7;
    }

    /* Gamification stats row */
    .habit-stats-row {
      display: flex; gap: 8px; padding: 10px 14px; flex-shrink: 0;
      border-top: 1px solid var(--border);
    }
    .habit-stat-card {
      flex: 1; background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 10px; padding: 10px 8px; text-align: center;
      transition: background 0.2s;
    }
    .habit-stat-card:hover { background: var(--bg-card-hover); }
    .habit-stat-icon { font-size: 16px; margin-bottom: 2px; }
    .habit-stat-value {
      font-size: 18px; font-weight: 700; line-height: 1.2;
      background: linear-gradient(135deg, var(--accent), #d4a8ff);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .habit-stat-value.green-val {
      background: linear-gradient(135deg, var(--green), #9ae8c0);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .habit-stat-value.blue-val {
      background: linear-gradient(135deg, var(--blue), #82b5f7);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .habit-stat-label {
      font-size: 9px; color: var(--text-muted); margin-top: 2px;
      text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;
    }

    /* === Manage sub-panel === */
    .habit-manage-scroll { flex: 1; overflow-y: auto; padding: 8px 14px; }

    /* Habit input row */
    .habit-input-row {
      display: flex; align-items: center; gap: 8px; padding: 8px 0; margin-bottom: 6px;
    }
    .habit-input-row input[type="text"] {
      flex: 1; background: transparent; border: none;
      border-bottom: 1px solid var(--border-light);
      color: var(--text-primary); font-size: 13px; padding: 6px 0; outline: none;
      font-family: inherit; transition: border-color 0.2s;
    }
    .habit-input-row input[type="text"]:focus { border-bottom-color: var(--accent); }
    .habit-input-row input[type="text"]::placeholder { color: var(--text-muted); font-style: italic; }
    .habit-freq-select {
      padding: 5px 18px 5px 8px; font-size: 10px; font-weight: 600; letter-spacing: 0.3px;
      border: 1px solid var(--border-light); border-radius: 6px;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='5' viewBox='0 0 8 5'%3E%3Cpath d='M0 0l4 5 4-5z' fill='%235a5c74'/%3E%3C/svg%3E") no-repeat right 6px center / 8px;
      color: var(--text-muted); cursor: pointer;
      transition: color 0.15s; font-family: inherit; outline: none;
      appearance: none; -webkit-appearance: none;
    }
    .habit-freq-select:hover { color: var(--text-secondary); }
    .habit-freq-select option { background: var(--bg-surface); color: var(--text-primary); }

    /* Habit list items */
    .habit-manage-item {
      display: flex; align-items: center; gap: 8px; padding: 8px 6px;
      border-radius: 8px; transition: background 0.15s; border: 1px solid transparent;
      position: relative;
    }
    .habit-manage-item:hover {
      background: var(--bg-card-hover); border-color: var(--border);
    }
    .habit-manage-name {
      flex: 1; font-size: 13px; color: var(--text-primary); font-weight: 500;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .habit-manage-name.inactive { color: var(--text-muted); }
    .habit-freq-badge {
      font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 600;
      letter-spacing: 0.3px; text-transform: uppercase; flex-shrink: 0;
      background: rgba(180, 142, 255, 0.1); color: var(--accent);
      border: 1px solid rgba(180, 142, 255, 0.2);
    }
    .habit-manage-date {
      font-size: 9.5px; color: var(--text-muted); opacity: 0;
      transition: opacity 0.15s; white-space: nowrap; flex-shrink: 0;
    }
    .habit-manage-item:hover .habit-manage-date { opacity: 0.65; }
    .habit-manage-btn {
      background: none; border: none; color: var(--text-muted); cursor: pointer;
      font-size: 13px; padding: 0 3px; opacity: 0; transition: opacity 0.15s, color 0.15s;
    }
    .habit-manage-item:hover .habit-manage-btn { opacity: 1; }
    .habit-manage-btn:hover { color: var(--red); }
    .habit-manage-btn.toggle-btn { opacity: 1; font-size: 11px; }
    .habit-manage-btn.toggle-btn.is-active { color: var(--green); }
    .habit-manage-btn.toggle-btn.is-inactive { color: var(--text-muted); }

    /* Performance section */
    .habit-perf-section {
      margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);
    }
    .habit-perf-title {
      font-size: 11px; font-weight: 600; color: var(--text-secondary);
      text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px;
    }

    /* Per-habit completion bars */
    .habit-bar-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
    }
    .habit-bar-label {
      font-size: 11px; color: var(--text-secondary); width: 90px;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-shrink: 0;
    }
    .habit-bar-track {
      flex: 1; height: 8px; background: var(--bg-overlay); border-radius: 4px;
      overflow: hidden;
    }
    .habit-bar-fill {
      height: 100%; border-radius: 4px; transition: width 0.4s ease;
      background: linear-gradient(90deg, var(--accent), #d4a8ff);
    }
    .habit-bar-pct {
      font-size: 10px; font-weight: 600; color: var(--text-muted);
      width: 36px; text-align: right; flex-shrink: 0;
    }
    .habit-bar-streak {
      font-size: 9px; font-weight: 600; color: var(--accent);
      background: rgba(180, 142, 255, 0.1); border-radius: 4px;
      padding: 1px 5px; flex-shrink: 0; white-space: nowrap;
    }

    /* XP bar */
    .habit-xp-section {
      margin-top: 12px; padding: 10px; background: var(--bg-card);
      border: 1px solid var(--border); border-radius: 10px;
    }
    .habit-xp-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;
    }
    .habit-xp-level {
      font-size: 12px; font-weight: 700;
      background: linear-gradient(135deg, var(--accent), var(--blue));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .habit-xp-text {
      font-size: 10px; color: var(--text-muted); font-weight: 500;
    }
    .habit-xp-track {
      height: 10px; background: var(--bg-overlay); border-radius: 5px; overflow: hidden;
    }
    .habit-xp-fill {
      height: 100%; border-radius: 5px; transition: width 0.4s ease;
      background: linear-gradient(90deg, var(--accent), var(--blue));
    }

    /* Weekly completion ring (SVG) */
    .habit-ring-container {
      display: flex; align-items: center; justify-content: center;
      position: relative; width: 54px; height: 54px; margin: 0 auto;
    }
    .habit-ring-text {
      position: absolute; font-size: 12px; font-weight: 700;
      color: var(--text-primary);
    }

    /* 4-week heatmap */
    .habit-heatmap {
      display: grid; grid-template-columns: repeat(7, 1fr); gap: 3px;
      margin-top: 10px;
    }
    .habit-heatmap-cell {
      aspect-ratio: 1; border-radius: 3px; background: var(--bg-overlay);
      transition: background 0.2s; position: relative;
    }
    .habit-heatmap-cell[title]:hover::after {
      content: attr(title);
      position: absolute; bottom: calc(100% + 4px); left: 50%; transform: translateX(-50%);
      background: var(--bg-surface); color: var(--text-primary);
      font-size: 9px; padding: 3px 6px; border-radius: 4px; white-space: nowrap;
      border: 1px solid var(--border-light); z-index: 10; pointer-events: none;
    }
    .habit-heatmap-label {
      font-size: 9px; color: var(--text-muted); text-align: center;
      letter-spacing: 0.3px;
    }

    /* Streak glow milestone animation */
    @keyframes streak-glow {
      0%, 100% { box-shadow: 0 0 0 rgba(180, 142, 255, 0); }
      50% { box-shadow: 0 0 12px rgba(180, 142, 255, 0.4); }
    }
    .habit-stat-card.milestone { animation: streak-glow 1.5s ease-in-out 3; }

    /* Streak at risk pulse */
    @keyframes risk-pulse {
      0%, 100% { box-shadow: 0 0 0 rgba(240, 98, 146, 0); }
      50% { box-shadow: 0 0 10px rgba(240, 98, 146, 0.35); }
    }
    .habit-stat-card.at-risk {
      animation: risk-pulse 1.5s ease-in-out infinite;
      border-color: rgba(240, 98, 146, 0.3);
    }
    .habit-stat-card.at-risk .habit-stat-label { color: var(--red); }

    /* === Configurable Dashboard === */
    .dashboard {
      position: relative;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-content: start;
      grid-auto-rows: min-content;
    }
    .dashboard-config-btn {
      position: sticky; top: 0; grid-column: 1 / -1; justify-self: end;
      z-index: 5; background: none; border: 1px solid var(--border-light);
      border-radius: 6px; color: var(--text-muted); cursor: pointer;
      font-size: 14px; padding: 3px 7px;
      transition: color 0.15s, border-color 0.15s, background 0.15s;
      font-family: inherit; line-height: 1; margin-bottom: -4px;
    }
    .dashboard-config-btn:hover {
      color: var(--text-primary); border-color: var(--accent);
      background: rgba(180, 142, 255, 0.08);
    }
    .dashboard-config-panel {
      position: fixed; z-index: 100;
      background: var(--bg-surface); border: 1px solid var(--border-light);
      border-radius: 10px; width: 260px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      display: flex; flex-direction: column;
      max-height: 70vh;
    }
    .dashboard-config-panel.hidden { display: none; }
    .dashboard-config-title {
      font-size: 11px; font-weight: 600; color: var(--text-secondary);
      text-transform: uppercase; letter-spacing: 0.5px;
      padding: 12px 14px 8px; flex-shrink: 0;
    }
    .dashboard-config-list {
      display: flex; flex-direction: column; gap: 2px;
      overflow-y: auto; padding: 0 14px; flex: 1; min-height: 0;
    }
    .dashboard-config-item {
      display: flex; align-items: center; gap: 8px; padding: 5px 6px;
      border-radius: 6px; cursor: pointer; transition: background 0.15s;
      font-size: 12px; color: var(--text-primary); user-select: none;
      flex-shrink: 0;
    }
    .dashboard-config-item:hover { background: var(--bg-card-hover); }
    .dashboard-config-item input[type="checkbox"] {
      appearance: none; -webkit-appearance: none;
      width: 15px; height: 15px; border: 2px solid var(--text-muted);
      border-radius: 4px; cursor: pointer; flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s; position: relative; background: transparent;
    }
    .dashboard-config-item input[type="checkbox"]:checked {
      background: var(--accent); border-color: var(--accent);
    }
    .dashboard-config-item input[type="checkbox"]:checked::after {
      content: ''; position: absolute; left: 3px; top: 0px;
      width: 5px; height: 9px; border: solid white; border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    .dashboard-config-item .cfg-icon { font-size: 13px; flex-shrink: 0; width: 18px; text-align: center; }
    .dashboard-config-item .cfg-label { flex: 1; }
    .dashboard-config-done {
      width: calc(100% - 28px); padding: 7px; margin: 10px 14px 12px;
      background: var(--accent); border: none; border-radius: 6px;
      color: #fff; font-size: 11px; font-weight: 600; cursor: pointer;
      transition: opacity 0.2s; font-family: inherit; flex-shrink: 0;
    }
    .dashboard-config-done:hover { opacity: 0.85; }

    .dashboard-widget-full { grid-column: 1 / -1; }

    .dashboard-widget { cursor: grab; }
    .dashboard-widget > .stat-card { height: 100%; }
    .dashboard-widget:active { cursor: grabbing; }
    .dashboard-widget.dragging { opacity: 0.4; }
    .dashboard-widget.drag-over-top { border-top: 2px solid var(--accent); }
    .dashboard-widget.drag-over-bottom { border-bottom: 2px solid var(--accent); }
  </style>
</head>
<body>
  <!-- Onboarding -->
  <div class="onboarding-overlay hidden" id="onboarding">
    <div class="onboarding-card">
      <h1>Welcome to FloatNote</h1>
      <p>Let's personalize your experience.</p>
      <div class="onboarding-field">
        <label>Your Name</label>
        <input type="text" id="onboard-name" placeholder="Enter your name" maxlength="30" autocomplete="off">
      </div>
      <div class="onboarding-field">
        <label>Accent Colour</label>
        <select id="onboard-color">
          <option value="purple">Purple</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="pink">Pink</option>
          <option value="gold">Gold</option>
        </select>
      </div>
      <button class="onboarding-btn" id="onboard-go">Get Started</button>
      <div class="onboarding-error" id="onboard-error"></div>
    </div>
  </div>

  <div class="titlebar">
    <span class="titlebar-title">FloatNote</span>
    <div class="titlebar-buttons">
      <button class="titlebar-btn btn-minimize" id="btn-min"></button>
      <button class="titlebar-btn btn-close" id="btn-close"></button>
    </div>
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="dashboard">Dashboard</div>
    <div class="tab" data-tab="notes">Notes</div>
    <div class="tab" data-tab="checklist">Checklist</div>
    <div class="tab" data-tab="habits">Habits</div>
  </div>

  <!-- Dashboard -->
  <div class="panel active" id="panel-dashboard">
    <div class="dashboard" id="dashboard-container">
      <button class="dashboard-config-btn" id="dashboard-config-btn" title="Configure dashboard">&#x2699;</button>
      <!-- widgets rendered dynamically -->
    </div>
    <div class="dashboard-config-panel hidden" id="dashboard-config-panel">
      <div class="dashboard-config-title">Configure Dashboard</div>
      <div class="dashboard-config-list" id="dashboard-config-list"></div>
      <button class="dashboard-config-done" id="dashboard-config-done">Done</button>
    </div>
  </div>

  <!-- Notes -->
  <div class="panel" id="panel-notes">
    <div class="category-bar">
      <button class="cat-btn active-pro" data-cat="professional" id="notes-cat-pro">Professional</button>
      <button class="cat-btn" data-cat="personal" id="notes-cat-per">Personal</button>
    </div>
    <div class="notes-editor" id="notes-editor" contenteditable="true"></div>
  </div>

  <!-- Checklist -->
  <div class="panel" id="panel-checklist">
    <div class="category-bar">
      <button class="cat-btn active-pro" data-cat="professional" id="cl-cat-pro">Professional</button>
      <button class="cat-btn" data-cat="personal" id="cl-cat-per">Personal</button>
    </div>
    <div class="checklist-toolbar">
      <select class="sort-select" id="sort-select">
        <option value="none">&#x21F5; Sort</option>
        <option value="date">Date added</option>
        <option value="priority">Priority</option>
      </select>
      <button class="clean-btn" id="clean-btn">Clean list</button>
    </div>
    <div class="checklist-items" id="checklist-items"></div>
  </div>

  <!-- Habits -->
  <div class="panel" id="panel-habits">
    <div class="category-bar">
      <button class="cat-btn active-habit" id="habit-tab-tracker">Habit Tracker</button>
      <button class="cat-btn" id="habit-tab-manage">Input &amp; Performance</button>
    </div>

    <!-- Tracker sub-panel (default) -->
    <div class="habit-subpanel active" id="habit-view-tracker">
      <div class="habit-week-nav">
        <button id="habit-prev-week">&laquo; Prev</button>
        <span class="habit-week-label" id="habit-week-label">This Week</span>
        <button id="habit-next-week" disabled>Next &raquo;</button>
      </div>
      <div class="habit-grid" id="habit-grid"></div>
      <div class="habit-stats-row" id="habit-stats-row"></div>
    </div>

    <!-- Manage sub-panel -->
    <div class="habit-subpanel" id="habit-view-manage">
      <div class="habit-manage-scroll">
        <div class="habit-input-row">
          <input type="text" id="habit-name-input" placeholder="New habit name..." autocomplete="off">
          <select class="habit-freq-select" id="habit-freq-select">
            <option value="daily">Daily</option>
            <option value="weekdays">Weekdays</option>
            <option value="weekends">Weekends</option>
            <option value="5x_week">5x/week</option>
            <option value="4x_week">4x/week</option>
            <option value="3x_week">3x/week</option>
            <option value="2x_week">2x/week</option>
            <option value="1x_week">1x/week</option>
          </select>
        </div>
        <div id="habit-manage-list"></div>
        <div class="habit-perf-section" id="habit-performance"></div>
      </div>
    </div>
  </div>

  <script>
    // --- Stoic Quotes ---
    const STOIC_QUOTES = [
      { text: "We suffer more often in imagination than in reality.", author: "Seneca" },
      { text: "The happiness of your life depends upon the quality of your thoughts.", author: "Marcus Aurelius" },
      { text: "Man is not worried by real problems so much as by his imagined anxieties about real problems.", author: "Epictetus" },
      { text: "Waste no more time arguing about what a good man should be. Be one.", author: "Marcus Aurelius" },
      { text: "He who fears death will never do anything worthy of a man who is alive.", author: "Seneca" },
      { text: "It is not that we have a short time to live, but that we waste a great deal of it.", author: "Seneca" },
      { text: "You have power over your mind, not outside events. Realize this, and you will find strength.", author: "Marcus Aurelius" },
      { text: "First say to yourself what you would be; and then do what you have to do.", author: "Epictetus" },
      { text: "The best revenge is not to be like your enemy.", author: "Marcus Aurelius" },
      { text: "Difficulties strengthen the mind, as labor does the body.", author: "Seneca" },
      { text: "No man is free who is not master of himself.", author: "Epictetus" },
      { text: "If it is not right, do not do it; if it is not true, do not say it.", author: "Marcus Aurelius" },
      { text: "We are more often frightened than hurt; and we suffer more from imagination than from reality.", author: "Seneca" },
      { text: "How long are you going to wait before you demand the best for yourself?", author: "Epictetus" },
      { text: "The soul becomes dyed with the colour of its thoughts.", author: "Marcus Aurelius" },
      { text: "True happiness is to enjoy the present, without anxious dependence upon the future.", author: "Seneca" },
      { text: "Make the best use of what is in your power, and take the rest as it happens.", author: "Epictetus" },
      { text: "Very little is needed to make a happy life; it is all within yourself, in your way of thinking.", author: "Marcus Aurelius" },
      { text: "Luck is what happens when preparation meets opportunity.", author: "Seneca" },
      { text: "It's not what happens to you, but how you react to it that matters.", author: "Epictetus" },
      { text: "Never let the future disturb you. You will meet it, if you have to, with the same weapons of reason which today arm you against the present.", author: "Marcus Aurelius" },
      { text: "A gem cannot be polished without friction, nor a man perfected without trials.", author: "Seneca" },
      { text: "Wealth consists not in having great possessions, but in having few wants.", author: "Epictetus" },
      { text: "The impediment to action advances action. What stands in the way becomes the way.", author: "Marcus Aurelius" },
      { text: "Begin at once to live, and count each separate day as a separate life.", author: "Seneca" },
      { text: "Don't explain your philosophy. Embody it.", author: "Epictetus" },
      { text: "When you arise in the morning, think of what a precious privilege it is to be alive.", author: "Marcus Aurelius" },
      { text: "As is a tale, so is life: not how long it is, but how good it is, is what matters.", author: "Seneca" },
      { text: "Only the educated are free.", author: "Epictetus" },
      { text: "Dwell on the beauty of life. Watch the stars, and see yourself running with them.", author: "Marcus Aurelius" },
      { text: "Every new beginning comes from some other beginning's end.", author: "Seneca" },
      { text: "He is a wise man who does not grieve for the things which he has not, but rejoices for those which he has.", author: "Epictetus" },
      { text: "Accept the things to which fate binds you, and love the people with whom fate brings you together.", author: "Marcus Aurelius" },
      { text: "Sometimes even to live is an act of courage.", author: "Seneca" },
      { text: "There is only one way to happiness and that is to cease worrying about things which are beyond the power of our will.", author: "Epictetus" },
      { text: "The object of life is not to be on the side of the majority, but to escape finding oneself in the ranks of the insane.", author: "Marcus Aurelius" },
      // Nietzsche
      { text: "Without music, life would be a mistake.", author: "Nietzsche" },
      { text: "That which does not kill us makes us stronger.", author: "Nietzsche" },
      { text: "He who has a why to live can bear almost any how.", author: "Nietzsche" },
      { text: "One must still have chaos in oneself to be able to give birth to a dancing star.", author: "Nietzsche" },
      { text: "The higher we soar, the smaller we appear to those who cannot fly.", author: "Nietzsche" },
      { text: "Become who you are.", author: "Nietzsche" },
      { text: "The secret for harvesting from existence the greatest fruitfulness and the greatest enjoyment is to live dangerously.", author: "Nietzsche" },
      // Kierkegaard
      { text: "Life can only be understood backwards; but it must be lived forwards.", author: "Kierkegaard" },
      { text: "The most common form of despair is not being who you are.", author: "Kierkegaard" },
      { text: "Anxiety is the dizziness of freedom.", author: "Kierkegaard" },
      { text: "To dare is to lose one's footing momentarily. Not to dare is to lose oneself.", author: "Kierkegaard" },
      { text: "Once you label me you negate me.", author: "Kierkegaard" },
      { text: "The highest and most beautiful things in life are not to be heard about, nor read about, nor seen, but, if one will, are to be lived.", author: "Kierkegaard" },
      // Sartre
      { text: "We are condemned to be free.", author: "Sartre" },
      { text: "Man is nothing else but what he makes of himself.", author: "Sartre" },
      { text: "Freedom is what you do with what has been done to you.", author: "Sartre" },
      { text: "Everything has been figured out, except how to live.", author: "Sartre" },
      { text: "Existence precedes essence.", author: "Sartre" },
      { text: "Words are loaded pistols.", author: "Sartre" },
    ];

    let currentQuoteIndex = -1;

    function getRandomQuote() {
      let idx;
      do {
        idx = Math.floor(Math.random() * STOIC_QUOTES.length);
      } while (idx === currentQuoteIndex && STOIC_QUOTES.length > 1);
      currentQuoteIndex = idx;
      return STOIC_QUOTES[idx];
    }

    function showQuote(animate) {
      const textEl = document.getElementById('quote-text');
      const authorEl = document.getElementById('quote-author');
      if (!textEl || !authorEl) return;
      if (animate) {
        textEl.classList.add('fading');
        authorEl.classList.add('fading');
        setTimeout(() => {
          const q = getRandomQuote();
          textEl.textContent = q.text;
          authorEl.textContent = '\u2014 ' + q.author;
          textEl.classList.remove('fading');
          authorEl.classList.remove('fading');
        }, 350);
      } else {
        const q = getRandomQuote();
        textEl.textContent = q.text;
        authorEl.textContent = '\u2014 ' + q.author;
      }
    }

    // --- Colour themes ---
    const COLOUR_MAP = {
      purple: { accent: '#b48eff', glow: 'rgba(180, 142, 255, 0.25)' },
      blue:   { accent: '#5b9cf5', glow: 'rgba(91, 156, 245, 0.25)' },
      green:  { accent: '#6dd4a0', glow: 'rgba(109, 212, 160, 0.25)' },
      pink:   { accent: '#f06292', glow: 'rgba(240, 98, 146, 0.25)' },
      gold:   { accent: '#ffd180', glow: 'rgba(255, 209, 128, 0.25)' }
    };

    function applyPreferences(prefs) {
      if (!prefs) return;
      const theme = COLOUR_MAP[prefs.color] || COLOUR_MAP.purple;
      document.documentElement.style.setProperty('--accent', theme.accent);
      document.documentElement.style.setProperty('--accent-glow', theme.glow);
      document.querySelector('.titlebar-title').textContent = prefs.name + "'s FloatNote";
    }

    // --- State ---
    let state = {
      notes: { professional: '', personal: '' },
      checklist: { professional: [], personal: [] },
      completionLog: [],
      preferences: null,
      habits: [],
      habitLog: {},
      dashboardConfig: null
    };
    let saveTimeout = null;
    let activeNotesCategory = 'professional';
    let activeChecklistCategory = 'professional';
    let chartMode = 'daily'; // 'daily' or 'cumulative'
    let checklistSort = 'none'; // 'none' | 'date' | 'priority'
    let activeHabitView = 'tracker'; // 'tracker' | 'manage'
    let habitWeekOffset = 0; // 0 = current week, -1 = last week, etc.

    // --- Custom undo/redo stack for DOM transformations ---
    const undoStack = [];
    const redoStack = [];
    const MAX_UNDO = 100;

    function pushUndo() {
      const editor = document.getElementById('notes-editor');
      if (!editor) return;
      const html = editor.innerHTML;
      if (undoStack.length && undoStack[undoStack.length - 1] === html) return; // no duplicate
      undoStack.push(html);
      if (undoStack.length > MAX_UNDO) undoStack.shift();
      redoStack.length = 0; // clear redo on new action
    }

    function performUndo() {
      const editor = document.getElementById('notes-editor');
      if (!undoStack.length) return false;
      redoStack.push(editor.innerHTML);
      const prev = undoStack.pop();
      editor.innerHTML = prev;
      state.notes[activeNotesCategory] = prev;
      scheduleSave();
      return true;
    }

    function performRedo() {
      const editor = document.getElementById('notes-editor');
      if (!redoStack.length) return false;
      undoStack.push(editor.innerHTML);
      const next = redoStack.pop();
      editor.innerHTML = next;
      state.notes[activeNotesCategory] = next;
      scheduleSave();
      return true;
    }

    // --- Persistence ---
    async function load() {
      const loaded = await window.api.loadData();
      state.notes = loaded.notes || { professional: '', personal: '' };
      state.checklist = loaded.checklist || { professional: [], personal: [] };
      state.completionLog = loaded.completionLog || [];
      state.preferences = loaded.preferences || null;
      state.habits = loaded.habits || [];
      state.habitLog = loaded.habitLog || {};
      state.dashboardConfig = loaded.dashboardConfig || null;

      if (state.preferences) {
        applyPreferences(state.preferences);
      } else {
        document.getElementById('onboarding').classList.remove('hidden');
      }

      // Migrate plain text notes to HTML (wrap in <div> if no HTML tags present)
      ['professional', 'personal'].forEach(cat => {
        const n = state.notes[cat];
        if (n && !/<[a-z][\s\S]*>/i.test(n)) {
          state.notes[cat] = n.split('\n').map(l => '<div>' + (l || '<br>') + '</div>').join('');
        }
      });

      document.getElementById('notes-editor').innerHTML = state.notes[activeNotesCategory] || '';
      renderChecklist();
      renderDashboard();
    }

    function scheduleSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => window.api.saveData(state), 300);
    }

    function toDateStr(d) {
      return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
    }

    function todayStr() {
      return toDateStr(new Date());
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // --- Tabs ---
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
        if (tab.dataset.tab === 'dashboard') renderDashboard();
        if (tab.dataset.tab === 'habits') renderActiveHabitView();
      });
    });

    // --- Notes category toggle ---
    function setNotesCategory(cat) {
      activeNotesCategory = cat;
      document.getElementById('notes-cat-pro').className = 'cat-btn' + (cat === 'professional' ? ' active-pro' : '');
      document.getElementById('notes-cat-per').className = 'cat-btn' + (cat === 'personal' ? ' active-per' : '');
      document.getElementById('notes-editor').innerHTML = state.notes[cat] || '';
      // Reset undo/redo stacks on category switch
      undoStack.length = 0;
      redoStack.length = 0;
    }
    document.getElementById('notes-cat-pro').addEventListener('click', () => setNotesCategory('professional'));
    document.getElementById('notes-cat-per').addEventListener('click', () => setNotesCategory('personal'));

    document.getElementById('notes-editor').addEventListener('input', (e) => {
      const editor = e.target;
      const sel = window.getSelection();
      if (sel.rangeCount) {
        const node = sel.anchorNode;
        if (node && node.nodeType === Node.TEXT_NODE) {
          let block = node.parentElement;
          while (block && block !== editor && block.parentElement !== editor) {
            block = block.parentElement;
          }
          const isDirectText = (block === editor);
          const container = isDirectText ? null : block;
          const fullText = node.textContent || '';
          const isSpecial = container && container.classList &&
            (container.classList.contains('note-bullet') || container.classList.contains('note-heading') ||
             container.classList.contains('note-title') || container.classList.contains('note-subheading') ||
             container.classList.contains('note-numbered') || container.classList.contains('note-checklist'));

          // Helper: replace node/container with a new element
          function replaceWith(el) {
            pushUndo();
            if (container) { container.replaceWith(el); } else { node.remove(); editor.appendChild(el); }
          }
          function placeCursor(el, atEnd) {
            const r = document.createRange();
            if (atEnd && el.firstChild && el.firstChild.nodeType === Node.TEXT_NODE) {
              r.setStart(el.firstChild, el.firstChild.textContent.length);
            } else { r.setStart(el, 0); }
            r.collapse(true); sel.removeAllRanges(); sel.addRange(r);
          }

          if (!isSpecial) {
            // Auto-detect "- "  bullet
            if (fullText.startsWith('- ') || fullText.startsWith('-\u00a0')) {
              const rest = fullText.slice(2);
              const bullet = document.createElement('div');
              bullet.className = 'note-bullet';
              bullet.textContent = rest || '';
              if (!rest) bullet.innerHTML = '<br>';
              replaceWith(bullet);
              placeCursor(bullet, !!rest);
            }
            // Auto-detect "### "  subheading (check longest first)
            else if (fullText.startsWith('### ') || fullText.startsWith('###\u00a0')) {
              const rest = fullText.slice(4);
              const el = document.createElement('div');
              el.className = 'note-subheading';
              el.textContent = rest || '';
              if (!rest) el.innerHTML = '<br>';
              const del = document.createElement('span');
              del.className = 'section-delete'; del.textContent = '\u00d7';
              del.setAttribute('contenteditable', 'false');
              el.appendChild(del);
              replaceWith(el);
              placeCursor(el, !!rest);
            }
            // Auto-detect "## "  heading
            else if (fullText.startsWith('## ') || fullText.startsWith('##\u00a0')) {
              const rest = fullText.slice(3);
              const el = document.createElement('div');
              el.className = 'note-heading';
              el.textContent = rest || '';
              if (!rest) el.innerHTML = '<br>';
              const del = document.createElement('span');
              del.className = 'section-delete'; del.textContent = '\u00d7';
              del.setAttribute('contenteditable', 'false');
              el.appendChild(del);
              replaceWith(el);
              placeCursor(el, !!rest);
            }
            // Auto-detect "# "  title
            else if (fullText.startsWith('# ') || fullText.startsWith('#\u00a0')) {
              const rest = fullText.slice(2);
              const el = document.createElement('div');
              el.className = 'note-title';
              el.textContent = rest || '';
              if (!rest) el.innerHTML = '<br>';
              const del = document.createElement('span');
              del.className = 'section-delete'; del.textContent = '\u00d7';
              del.setAttribute('contenteditable', 'false');
              el.appendChild(del);
              replaceWith(el);
              placeCursor(el, !!rest);
            }
            // Auto-detect "1. " (digit + ". ")  numbered list
            else if (/^\d+\.\s/.test(fullText) || /^\d+\.\u00a0/.test(fullText)) {
              const match = fullText.match(/^(\d+)[.\u00a0]\s?/);
              const rest = fullText.slice(match[0].length);
              const el = document.createElement('div');
              el.className = 'note-numbered';
              el.setAttribute('data-num', match[1]);
              el.textContent = rest || '';
              if (!rest) el.innerHTML = '<br>';
              replaceWith(el);
              placeCursor(el, !!rest);
            }
            // Auto-detect "[] " or "[ ] "  checklist
            else if (fullText.startsWith('[] ') || fullText.startsWith('[]\u00a0') ||
                     fullText.startsWith('[ ] ') || fullText.startsWith('[ ]\u00a0')) {
              const sliceLen = fullText.startsWith('[ ]') ? 4 : 3;
              const rest = fullText.slice(sliceLen);
              const cl = document.createElement('div');
              cl.className = 'note-checklist';
              const cb = document.createElement('input');
              cb.type = 'checkbox'; cb.className = 'check-box';
              cb.setAttribute('contenteditable', 'false');
              const span = document.createElement('span');
              span.className = 'check-text';
              span.setAttribute('contenteditable', 'true');
              span.textContent = rest || '';
              if (!rest) span.innerHTML = '<br>';
              cl.appendChild(cb); cl.appendChild(span);
              replaceWith(cl);
              const r = document.createRange();
              if (rest) { r.setStart(span.firstChild, rest.length); }
              else { r.setStart(span, 0); }
              r.collapse(true); sel.removeAllRanges(); sel.addRange(r);
            }
          }

          // Inline code: detect closing backtick pattern `text`
          const backtickMatch = fullText.match(/`([^`]+)`$/);
          if (backtickMatch) {
            pushUndo();
            const codeText = backtickMatch[1];
            const matchStart = fullText.lastIndexOf('`' + codeText + '`');
            // Split text node: before, code, after
            const before = fullText.slice(0, matchStart);
            const textNode = node;
            const parent = textNode.parentNode;
            // Clear the backtick pattern and insert code element
            textNode.textContent = before;
            const codeEl = document.createElement('code');
            codeEl.textContent = codeText;
            const afterNode = document.createTextNode('\u00a0');
            if (textNode.nextSibling) {
              parent.insertBefore(codeEl, textNode.nextSibling);
              parent.insertBefore(afterNode, codeEl.nextSibling);
            } else {
              parent.appendChild(codeEl);
              parent.appendChild(afterNode);
            }
            const r = document.createRange();
            r.setStart(afterNode, 1);
            r.collapse(true);
            sel.removeAllRanges();
            sel.addRange(r);
          }
        }
      }
      state.notes[activeNotesCategory] = editor.innerHTML;
      scheduleSave();
    });

    // --- Notes: keyboard handlers ---
    document.getElementById('notes-editor').addEventListener('keydown', (e) => {
      const editor = e.currentTarget;

      // Ctrl+Z: undo (custom stack)
      if (e.ctrlKey && !e.shiftKey && e.key === 'z') {
        e.preventDefault();
        performUndo();
        return;
      }

      // Ctrl+Y or Ctrl+Shift+Z: redo
      if ((e.ctrlKey && !e.shiftKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'Z')) {
        e.preventDefault();
        performRedo();
        return;
      }

      // Snapshot undo state before any custom transformation
      // (skip for navigation keys, typing, and undo/redo itself)
      const transformKeys = ['b','i','u','h','l','S','H','L','Tab','Backspace','Enter'];
      if (e.ctrlKey || e.key === 'Tab' || e.key === 'Backspace' || e.key === 'Enter') {
        const k = e.key;
        if (transformKeys.includes(k) || (e.ctrlKey && transformKeys.includes(k.toLowerCase()))) {
          pushUndo();
        }
      }

      // Ctrl+B: toggle bold (inline formatting)
      if (e.ctrlKey && !e.shiftKey && e.key === 'b') {
        e.preventDefault();
        document.execCommand('bold');
        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+I: toggle italic
      if (e.ctrlKey && !e.shiftKey && e.key === 'i') {
        e.preventDefault();
        document.execCommand('italic');
        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+U: toggle underline
      if (e.ctrlKey && !e.shiftKey && e.key === 'u') {
        e.preventDefault();
        document.execCommand('underline');
        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+Shift+S: toggle strikethrough
      if (e.ctrlKey && e.shiftKey && e.key === 'S') {
        e.preventDefault();
        document.execCommand('strikeThrough');
        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+H or Ctrl+Shift+H: wrap selected text as section heading
      if (e.ctrlKey && (e.key === 'h' || e.key === 'H')) {
        e.preventDefault();
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const range = sel.getRangeAt(0);
        const selectedText = range.toString().trim();
        if (!selectedText) return;

        range.deleteContents();
        const heading = document.createElement('div');
        heading.className = 'note-heading';
        heading.textContent = selectedText;
        const del = document.createElement('span');
        del.className = 'section-delete';
        del.textContent = '\u00d7';
        del.setAttribute('contenteditable', 'false');
        heading.appendChild(del);
        range.insertNode(heading);

        const r = document.createRange();
        r.setStartAfter(heading);
        r.collapse(true);
        sel.removeAllRanges();
        sel.addRange(r);

        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+Shift+L: toggle checklist on current line
      if (e.ctrlKey && e.shiftKey && e.key === 'L') {
        e.preventDefault();
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const node = sel.anchorNode;
        let block = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
        while (block && block !== editor && block.parentElement !== editor) {
          block = block.parentElement;
        }
        // If inside a check-text span, go up to note-checklist
        if (block && block.classList && block.classList.contains('check-text')) {
          block = block.parentElement;
        }

        if (block && block.classList && block.classList.contains('note-checklist')) {
          // Unwrap checklist to plain div
          const textSpan = block.querySelector('.check-text');
          const plain = document.createElement('div');
          plain.textContent = (textSpan ? textSpan.textContent : block.textContent) || '';
          if (!plain.textContent) plain.innerHTML = '<br>';
          block.replaceWith(plain);
          const r = document.createRange();
          r.selectNodeContents(plain);
          r.collapse(false);
          sel.removeAllRanges();
          sel.addRange(r);
        } else if (block && block !== editor && block.tagName === 'DIV') {
          // Convert to checklist
          const text = block.textContent || '';
          const cl = document.createElement('div');
          cl.className = 'note-checklist';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.className = 'check-box';
          cb.setAttribute('contenteditable', 'false');
          const span = document.createElement('span');
          span.className = 'check-text';
          span.setAttribute('contenteditable', 'true');
          span.textContent = text;
          if (!text) span.innerHTML = '<br>';
          cl.appendChild(cb);
          cl.appendChild(span);
          block.replaceWith(cl);
          const r = document.createRange();
          r.selectNodeContents(span);
          r.collapse(false);
          sel.removeAllRanges();
          sel.addRange(r);
        }
        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Ctrl+L: toggle bullet on selected text / current line(s)
      if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        const sel = window.getSelection();
        if (!sel.rangeCount) return;

        // Helper: find direct-child block of editor for a given node
        function findBlock(n) {
          let b = n.nodeType === Node.TEXT_NODE ? n.parentElement : n;
          while (b && b !== editor && b.parentElement !== editor) b = b.parentElement;
          return (b && b !== editor) ? b : null;
        }

        // Collect all direct-child blocks in the selection range
        const range = sel.getRangeAt(0);
        const startBlock = findBlock(range.startContainer);
        const endBlock = findBlock(range.endContainer);

        const blocks = [];
        if (startBlock) {
          let cur = startBlock;
          while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE && cur.parentElement === editor) {
              blocks.push(cur);
            }
            if (cur === endBlock) break;
            cur = cur.nextElementSibling;
          }
        }

        // If no blocks found, fall back to single-block from anchor
        if (!blocks.length) {
          const b = findBlock(sel.anchorNode);
          if (b) blocks.push(b);
        }

        if (!blocks.length) return;

        // Determine toggle direction: if ALL are bullets, unbullet; otherwise bullet all
        const allBullets = blocks.every(b => b.classList && b.classList.contains('note-bullet'));
        const headingTypes = ['note-heading', 'note-title', 'note-subheading'];

        blocks.forEach(block => {
          if (allBullets) {
            // Unwrap bullet to plain div
            const plain = document.createElement('div');
            plain.textContent = block.textContent || '';
            if (!plain.textContent) plain.innerHTML = '<br>';
            block.replaceWith(plain);
          } else if (!block.classList.contains('note-bullet')) {
            // Convert to bullet (skip headings)
            const isHeading = headingTypes.some(h => block.classList.contains(h));
            if (!isHeading && block.tagName === 'DIV') {
              block.className = 'note-bullet';
            }
          }
        });

        state.notes[activeNotesCategory] = editor.innerHTML;
        scheduleSave();
        return;
      }

      // Tab / Shift+Tab: indent/outdent list items
      if (e.key === 'Tab') {
        e.preventDefault();
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const node = sel.anchorNode;
        let block = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
        while (block && block !== editor && block.parentElement !== editor) {
          block = block.parentElement;
        }
        // Also check if inside check-text
        if (block && block.classList && block.classList.contains('check-text')) {
          block = block.parentElement;
        }
        if (block && block.classList && (block.classList.contains('note-bullet') ||
            block.classList.contains('note-numbered') || block.classList.contains('note-checklist'))) {
          const curLevel = parseInt(block.getAttribute('data-indent') || '0');
          if (e.shiftKey) {
            // Outdent
            const newLevel = Math.max(0, curLevel - 1);
            block.setAttribute('data-indent', newLevel);
            block.classList.remove('indent-1', 'indent-2', 'indent-3');
            if (newLevel > 0) block.classList.add('indent-' + newLevel);
          } else {
            // Indent
            const newLevel = Math.min(3, curLevel + 1);
            block.setAttribute('data-indent', newLevel);
            block.classList.remove('indent-1', 'indent-2', 'indent-3');
            block.classList.add('indent-' + newLevel);
          }
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
        }
        return;
      }

      // Backspace: unwrap headings/titles/subheadings back to plain text
      if (e.key === 'Backspace') {
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        let node = sel.anchorNode;
        const hEl = node.nodeType === Node.TEXT_NODE
          ? node.parentElement.closest('.note-heading, .note-title, .note-subheading')
          : node.closest('.note-heading, .note-title, .note-subheading');
        if (hEl && hEl.closest('.notes-editor') === editor) {
          const hText = hEl.textContent.replace('\u00d7', '').trim();
          if (!hText) {
            e.preventDefault();
            hEl.remove();
            state.notes[activeNotesCategory] = editor.innerHTML;
            scheduleSave();
            return;
          }
          if (sel.anchorOffset === 0 && node === hEl.firstChild) {
            e.preventDefault();
            const plain = document.createElement('div');
            plain.textContent = hText;
            hEl.parentNode.replaceChild(plain, hEl);
            const r = document.createRange();
            r.setStart(plain.firstChild, 0);
            r.collapse(true);
            sel.removeAllRanges();
            sel.addRange(r);
            state.notes[activeNotesCategory] = editor.innerHTML;
            scheduleSave();
          }
        }
        return;
      }

      // Enter: auto-continue bullets, numbered lists, and checklists
      if (e.key === 'Enter' && !e.shiftKey) {
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const node = sel.anchorNode;

        // Helper: find closest list-type ancestor
        let listItem = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
        while (listItem && listItem !== editor &&
               !listItem.classList.contains('note-bullet') &&
               !listItem.classList.contains('note-numbered') &&
               !listItem.classList.contains('note-checklist')) {
          listItem = listItem.parentElement;
        }
        if (!listItem || listItem === editor) return;

        // --- Bullet ---
        if (listItem.classList.contains('note-bullet')) {
          e.preventDefault();
          const text = listItem.textContent || '';
          if (!text.trim()) {
            const plain = document.createElement('div');
            plain.innerHTML = '<br>';
            listItem.replaceWith(plain);
            const r = document.createRange();
            r.setStart(plain, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          } else {
            const nb = document.createElement('div');
            nb.className = 'note-bullet';
            nb.innerHTML = '<br>';
            // Copy indent level
            const indent = listItem.getAttribute('data-indent');
            if (indent && indent !== '0') { nb.setAttribute('data-indent', indent); nb.classList.add('indent-' + indent); }
            listItem.after(nb);
            const r = document.createRange();
            r.setStart(nb, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          }
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
          return;
        }

        // --- Numbered list ---
        if (listItem.classList.contains('note-numbered')) {
          e.preventDefault();
          const text = listItem.textContent || '';
          if (!text.trim()) {
            const plain = document.createElement('div');
            plain.innerHTML = '<br>';
            listItem.replaceWith(plain);
            const r = document.createRange();
            r.setStart(plain, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          } else {
            const curNum = parseInt(listItem.getAttribute('data-num') || '1');
            const nn = document.createElement('div');
            nn.className = 'note-numbered';
            nn.setAttribute('data-num', curNum + 1);
            nn.innerHTML = '<br>';
            const indent = listItem.getAttribute('data-indent');
            if (indent && indent !== '0') { nn.setAttribute('data-indent', indent); nn.classList.add('indent-' + indent); }
            listItem.after(nn);
            // Renumber subsequent siblings
            let sib = nn.nextElementSibling;
            let num = curNum + 2;
            while (sib && sib.classList.contains('note-numbered')) {
              sib.setAttribute('data-num', num);
              num++;
              sib = sib.nextElementSibling;
            }
            const r = document.createRange();
            r.setStart(nn, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          }
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
          return;
        }

        // --- Checklist ---
        if (listItem.classList.contains('note-checklist')) {
          e.preventDefault();
          const textSpan = listItem.querySelector('.check-text');
          const text = textSpan ? textSpan.textContent : listItem.textContent;
          if (!text || !text.trim()) {
            const plain = document.createElement('div');
            plain.innerHTML = '<br>';
            listItem.replaceWith(plain);
            const r = document.createRange();
            r.setStart(plain, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          } else {
            const cl = document.createElement('div');
            cl.className = 'note-checklist';
            const cb = document.createElement('input');
            cb.type = 'checkbox'; cb.className = 'check-box';
            cb.setAttribute('contenteditable', 'false');
            const span = document.createElement('span');
            span.className = 'check-text';
            span.setAttribute('contenteditable', 'true');
            span.innerHTML = '<br>';
            cl.appendChild(cb); cl.appendChild(span);
            const indent = listItem.getAttribute('data-indent');
            if (indent && indent !== '0') { cl.setAttribute('data-indent', indent); cl.classList.add('indent-' + indent); }
            listItem.after(cl);
            const r = document.createRange();
            r.setStart(span, 0); r.collapse(true);
            sel.removeAllRanges(); sel.addRange(r);
          }
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
          return;
        }
      }
    });

    // --- Notes: paste handler (plain text by default) ---
    document.getElementById('notes-editor').addEventListener('paste', (e) => {
      // Ctrl+Shift+V: allow rich paste (don't prevent default)
      if (e.ctrlKey && e.shiftKey) return;
      // Default: paste as plain text
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text/plain');
      document.execCommand('insertText', false, text);
    });

    // --- Notes: section delete + checkbox toggle via event delegation ---
    document.getElementById('notes-editor').addEventListener('click', (e) => {
      // Section delete button ()
      if (e.target.classList.contains('section-delete')) {
        e.preventDefault();
        e.stopPropagation();
        const heading = e.target.closest('.note-heading, .note-title, .note-subheading');
        if (heading) {
          heading.remove();
          const editor = document.getElementById('notes-editor');
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
        }
      }
    });

    // --- Notes: checklist checkbox change ---
    document.getElementById('notes-editor').addEventListener('change', (e) => {
      if (e.target.classList.contains('check-box')) {
        const cl = e.target.closest('.note-checklist');
        if (cl) {
          if (e.target.checked) {
            cl.classList.add('checked');
          } else {
            cl.classList.remove('checked');
          }
          const editor = document.getElementById('notes-editor');
          state.notes[activeNotesCategory] = editor.innerHTML;
          scheduleSave();
        }
      }
    });

    // --- Checklist category toggle ---
    function setChecklistCategory(cat) {
      activeChecklistCategory = cat;
      document.getElementById('cl-cat-pro').className = 'cat-btn' + (cat === 'professional' ? ' active-pro' : '');
      document.getElementById('cl-cat-per').className = 'cat-btn' + (cat === 'personal' ? ' active-per' : '');
      renderChecklist();
    }
    document.getElementById('cl-cat-pro').addEventListener('click', () => setChecklistCategory('professional'));
    document.getElementById('cl-cat-per').addEventListener('click', () => setChecklistCategory('personal'));

    // --- Checklist ---
    const PRIORITY_CYCLE = ['none', 'high', 'medium', 'low'];

    function getSortedItems(items) {
      const indexed = items.map((item, i) => ({ item, originalIndex: i }));
      if (checklistSort === 'date') {
        indexed.sort((a, b) => {
          if (!a.item.addedAt && !b.item.addedAt) return 0;
          if (!a.item.addedAt) return 1;
          if (!b.item.addedAt) return -1;
          return a.item.addedAt.localeCompare(b.item.addedAt);
        });
      } else if (checklistSort === 'priority') {
        const order = { high: 0, medium: 1, low: 2, none: 3 };
        indexed.sort((a, b) => order[a.item.priority || 'none'] - order[b.item.priority || 'none']);
      }
      return indexed;
    }

    function formatDeadline(dateStr) {
      if (!dateStr) return '';
      const d = new Date(dateStr + 'T00:00:00');
      return 'Due ' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    function isOverdue(dateStr) {
      if (!dateStr) return false;
      return dateStr < todayStr();
    }

    function formatAddedDate(dateStr) {
      if (!dateStr) return 'Date unknown';
      const d = new Date(dateStr + 'T00:00:00');
      return 'Added ' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function getAllChecklistItems() {
      return [...(state.checklist.professional || []), ...(state.checklist.personal || [])];
    }

    function renderChecklist(scrollToBottom) {
      const cat = activeChecklistCategory;
      const items = state.checklist[cat] || [];
      const container = document.getElementById('checklist-items');
      document.querySelectorAll('input[data-checklist-picker]').forEach(el => el.remove());
      container.innerHTML = '';

      getSortedItems(items).forEach(({ item, originalIndex: i }) => {
        const priority = item.priority || 'none';
        const div = document.createElement('div');
        div.className = 'checklist-item' + (item.done ? ' checked' : '') + (priority !== 'none' ? ' priority-' + priority : '');

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = item.done;
        cb.addEventListener('change', () => {
          const wasDone = state.checklist[cat][i].done;
          state.checklist[cat][i].done = cb.checked;
          if (cb.checked && !wasDone) {
            state.completionLog.push({ date: todayStr(), category: cat });
          } else if (!cb.checked && wasDone) {
            for (let j = state.completionLog.length - 1; j >= 0; j--) {
              if (state.completionLog[j].category === cat) {
                state.completionLog.splice(j, 1);
                break;
              }
            }
          }
          scheduleSave();
          renderChecklist();
        });

        const span = document.createElement('span');
        span.className = 'item-text';
        span.textContent = item.text;

        const dateBadge = document.createElement('span');
        dateBadge.className = 'item-date-badge';
        dateBadge.textContent = formatAddedDate(item.addedAt);

        // Deadline: hidden date input + calendar button
        const deadlineInput = document.createElement('input');
        deadlineInput.type = 'date';
        deadlineInput.dataset.checklistPicker = 'true';
        deadlineInput.style.cssText = 'position:fixed;top:-200px;left:-200px;opacity:0;width:0;height:0;border:0;padding:0;';
        if (item.deadline) deadlineInput.value = item.deadline;
        deadlineInput.addEventListener('change', () => {
          const val = deadlineInput.value || undefined;
          if (val) state.checklist[cat][i].deadline = val;
          else delete state.checklist[cat][i].deadline;
          if (deadlineInput.parentNode) deadlineInput.parentNode.removeChild(deadlineInput);
          scheduleSave();
          renderChecklist();
        });

        const dlOverdue = item.deadline && isOverdue(item.deadline);
        const deadlineBtn = document.createElement('button');
        deadlineBtn.className = 'deadline-btn' + (item.deadline ? (dlOverdue ? ' overdue' : ' has-deadline') : '');
        deadlineBtn.textContent = '\uD83D\uDCC5';
        deadlineBtn.title = item.deadline ? 'Change deadline' : 'Set deadline';
        deadlineBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!deadlineInput.parentNode) document.body.appendChild(deadlineInput);
          if (deadlineInput.showPicker) deadlineInput.showPicker();
          else deadlineInput.click();
        });

        const priorityBtn = document.createElement('button');
        priorityBtn.className = 'priority-btn' + (priority !== 'none' ? ' p-' + priority : '');
        priorityBtn.textContent = '\u2691';
        const priorityLabels = { none: 'Set priority', high: 'High priority', medium: 'Medium priority', low: 'Low priority' };
        priorityBtn.title = priorityLabels[priority];
        priorityBtn.addEventListener('click', () => {
          const cur = state.checklist[cat][i].priority || 'none';
          state.checklist[cat][i].priority = PRIORITY_CYCLE[(PRIORITY_CYCLE.indexOf(cur) + 1) % PRIORITY_CYCLE.length];
          scheduleSave();
          renderChecklist();
        });

        const del = document.createElement('button');
        del.className = 'delete-btn';
        del.textContent = '\u00d7';
        del.addEventListener('click', () => {
          state.checklist[cat].splice(i, 1);
          scheduleSave();
          renderChecklist();
        });

        div.appendChild(cb);
        div.appendChild(span);
        if (item.deadline) {
          const dlBadge = document.createElement('span');
          dlBadge.className = 'deadline-badge' + (dlOverdue ? ' overdue' : '');
          dlBadge.textContent = formatDeadline(item.deadline);
          div.appendChild(dlBadge);
        }
        div.appendChild(dateBadge);
        div.appendChild(deadlineBtn);
        div.appendChild(priorityBtn);
        div.appendChild(del);
        container.appendChild(div);
      });

      const inputRow = document.createElement('div');
      inputRow.className = 'inline-input';

      const bullet = document.createElement('div');
      bullet.className = 'bullet';

      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'Type a task and press Enter...';
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const text = input.value.trim();
          if (!text) return;
          if (!state.checklist[cat]) state.checklist[cat] = [];
          state.checklist[cat].push({ text, done: false, priority: 'none', addedAt: todayStr() });
          scheduleSave();
          renderChecklist(true);
          setTimeout(() => {
            const newInput = container.querySelector('.inline-input input');
            if (newInput) newInput.focus();
          }, 0);
        }
      });

      inputRow.appendChild(bullet);
      inputRow.appendChild(input);
      container.appendChild(inputRow);
      if (scrollToBottom) container.scrollTop = container.scrollHeight;
    }

    // --- Clean list ---
    function cleanChecklist() {
      const cat = activeChecklistCategory;
      const before = (state.checklist[cat] || []).length;
      state.checklist[cat] = (state.checklist[cat] || []).filter(item => !item.done);
      if (state.checklist[cat].length < before) {
        scheduleSave();
        renderChecklist();
      }
    }
    document.getElementById('clean-btn').addEventListener('click', cleanChecklist);

    document.getElementById('sort-select').addEventListener('change', (e) => {
      checklistSort = e.target.value;
      renderChecklist();
    });

    // Delegated click handlers for dynamically rendered dashboard elements
    document.addEventListener('click', (e) => {
      if (e.target.closest('#quote-card')) { showQuote(true); return; }
      if (e.target.id === 'chart-daily') {
        if (chartMode === 'daily') return;
        chartMode = 'daily';
        e.target.classList.add('active');
        const cum = document.getElementById('chart-cumulative');
        if (cum) cum.classList.remove('active');
        renderChart(state.completionLog || []);
      } else if (e.target.id === 'chart-cumulative') {
        if (chartMode === 'cumulative') return;
        chartMode = 'cumulative';
        e.target.classList.add('active');
        const daily = document.getElementById('chart-daily');
        if (daily) daily.classList.remove('active');
        renderChart(state.completionLog || []);
      }
    });

    // --- Dashboard Widget Registry ---
    const DEFAULT_WIDGETS = ['quote', 'stat-completed', 'stat-pending', 'stat-pro', 'stat-per', 'chart-productivity'];

    const DASHBOARD_WIDGETS = [
      { id: 'stat-completed', label: 'Total Completed', type: 'stat', icon: '\uD83C\uDFAF',
        render: (el) => {
          const v = (state.completionLog || []).length;
          el.innerHTML = '<div class="stat-icon">\uD83C\uDFAF</div><div class="stat-value">' + v + '</div><div class="stat-label">Completed</div>';
        }
      },
      { id: 'stat-pending', label: 'Open Tasks', type: 'stat', icon: '\uD83D\uDCCB',
        render: (el) => {
          const v = (state.checklist.professional || []).filter(i => !i.done).length + (state.checklist.personal || []).filter(i => !i.done).length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDCCB</div><div class="stat-value yellow">' + v + '</div><div class="stat-label">Open Tasks</div>';
        }
      },
      { id: 'stat-pro', label: 'Professional', type: 'stat', icon: '\uD83D\uDCBC',
        render: (el) => {
          const v = (state.completionLog || []).filter(e => e.category === 'professional').length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDCBC</div><div class="stat-value blue">' + v + '</div><div class="stat-label">Professional</div>';
        }
      },
      { id: 'stat-per', label: 'Personal', type: 'stat', icon: '\uD83C\uDF31',
        render: (el) => {
          const v = (state.completionLog || []).filter(e => e.category === 'personal').length;
          el.innerHTML = '<div class="stat-icon">\uD83C\uDF31</div><div class="stat-value green">' + v + '</div><div class="stat-label">Personal</div>';
        }
      },
      { id: 'stat-high', label: 'High Priority', type: 'stat', icon: '\uD83D\uDD34',
        render: (el) => {
          const all = getAllChecklistItems();
          const v = all.filter(i => !i.done && i.priority === 'high').length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDD34</div><div class="stat-value" style="background:linear-gradient(135deg,var(--red),#f48fb1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">' + v + '</div><div class="stat-label">High Priority</div>';
        }
      },
      { id: 'stat-medium', label: 'Medium Priority', type: 'stat', icon: '\uD83D\uDFE1',
        render: (el) => {
          const all = getAllChecklistItems();
          const v = all.filter(i => !i.done && i.priority === 'medium').length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDFE1</div><div class="stat-value yellow">' + v + '</div><div class="stat-label">Medium Priority</div>';
        }
      },
      { id: 'stat-low', label: 'Low Priority', type: 'stat', icon: '\uD83D\uDD35',
        render: (el) => {
          const all = getAllChecklistItems();
          const v = all.filter(i => !i.done && i.priority === 'low').length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDD35</div><div class="stat-value blue">' + v + '</div><div class="stat-label">Low Priority</div>';
        }
      },
      { id: 'stat-today', label: 'Completed Today', type: 'stat', icon: '\u2705',
        render: (el) => {
          const today = todayStr();
          const v = (state.completionLog || []).filter(e => e.date === today).length;
          el.innerHTML = '<div class="stat-icon">\u2705</div><div class="stat-value green">' + v + '</div><div class="stat-label">Done Today</div>';
        }
      },
      { id: 'stat-overdue', label: 'Overdue Tasks', type: 'stat', icon: '\u23F0',
        render: (el) => {
          const today = todayStr();
          const all = getAllChecklistItems();
          const v = all.filter(i => !i.done && i.deadline && i.deadline < today).length;
          el.innerHTML = '<div class="stat-icon">\u23F0</div><div class="stat-value" style="background:linear-gradient(135deg,var(--red),#f48fb1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">' + v + '</div><div class="stat-label">Overdue</div>';
        }
      },
      { id: 'stat-streak', label: 'Habit Day Streak', type: 'stat', icon: '\uD83D\uDD25',
        render: (el) => {
          const v = getDayStreak();
          el.innerHTML = '<div class="stat-icon">\uD83D\uDD25</div><div class="stat-value">' + v + '</div><div class="stat-label">Day Streak</div>';
        }
      },
      { id: 'stat-habits-today', label: 'Habits Done Today', type: 'stat', icon: '\uD83D\uDDD3',
        render: (el) => {
          const today = todayStr();
          const dow = new Date().getDay();
          const dayOfWeek = dow === 0 ? 6 : dow - 1;
          const active = (state.habits || []).filter(h => !h.archived);
          let done = 0, total = 0;
          active.forEach(h => {
            if (isHabitScheduled(h, dayOfWeek)) {
              total++;
              if (state.habitLog[h.id + ':' + today]) done++;
            }
          });
          el.innerHTML = '<div class="stat-icon">\uD83D\uDDD3</div><div class="stat-value green">' + done + '/' + total + '</div><div class="stat-label">Habits Today</div>';
        }
      },
      { id: 'stat-habits-active', label: 'Active Habits', type: 'stat', icon: '\uD83D\uDCAA',
        render: (el) => {
          const v = (state.habits || []).filter(h => !h.archived).length;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDCAA</div><div class="stat-value blue">' + v + '</div><div class="stat-label">Active Habits</div>';
        }
      },
      { id: 'stat-best-habit', label: 'Best Habit Streak', type: 'stat', icon: '\uD83C\uDFC6',
        render: (el) => {
          const active = (state.habits || []).filter(h => !h.archived);
          let best = 0;
          active.forEach(h => { const s = getHabitStreak(h.id); if (s > best) best = s; });
          el.innerHTML = '<div class="stat-icon">\uD83C\uDFC6</div><div class="stat-value">' + best + '</div><div class="stat-label">Best Streak</div>';
        }
      },
      { id: 'stat-week-pct', label: 'Week Habit %', type: 'stat', icon: '\uD83D\uDCC8',
        render: (el) => {
          const weekDays = getWeekDays(0);
          const active = (state.habits || []).filter(h => !h.archived);
          let completed = 0, scheduled = 0;
          active.forEach(h => {
            const wc = getWeeklyCompletion(h.id, weekDays);
            completed += wc.completed;
            scheduled += wc.scheduled;
          });
          const pct = scheduled > 0 ? Math.round((completed / scheduled) * 100) : 0;
          el.innerHTML = '<div class="stat-icon">\uD83D\uDCC8</div><div class="stat-value green">' + pct + '%</div><div class="stat-label">This Week</div>';
        }
      },
      { id: 'stat-xp', label: 'XP Level', type: 'stat', icon: '\u2B50',
        render: (el) => {
          const xp = getXPLevel();
          el.innerHTML = '<div class="stat-icon">\u2B50</div><div class="stat-value blue">Lv ' + xp.level + '</div><div class="stat-label">' + xp.xpInLevel + '/' + xp.xpNeeded + ' XP</div>';
        }
      },
      { id: 'stat-avg-daily', label: 'Avg Tasks/Day', type: 'stat', icon: '\uD83D\uDCC9',
        render: (el) => {
          const cutoff = new Date();
          cutoff.setDate(cutoff.getDate() - 13);
          const cutoffStr = toDateStr(cutoff);
          let count = 0;
          (state.completionLog || []).forEach(e => { if (e.date >= cutoffStr) count++; });
          const avg = (count / 14).toFixed(1);
          el.innerHTML = '<div class="stat-icon">\uD83D\uDCC9</div><div class="stat-value">' + avg + '</div><div class="stat-label">Avg/Day (14d)</div>';
        }
      },
      { id: 'quote', label: 'Stoic Quote', type: 'full', icon: '\uD83D\uDCDC',
        render: (el) => {
          const q = getRandomQuote();
          el.innerHTML = '<div class="quote-card" id="quote-card" title="Click for a new quote"><div class="quote-text" id="quote-text">' + escapeHtml(q.text) + '</div><div class="quote-author" id="quote-author">\u2014 ' + escapeHtml(q.author) + '</div><div class="quote-hint">click for another</div></div>';
        }
      },
      { id: 'chart-productivity', label: 'Productivity Chart', type: 'full', icon: '\uD83D\uDCCA',
        render: (el) => {
          el.innerHTML = '<div class="chart-container"><div class="chart-header"><div class="chart-title">Productivity</div><div class="chart-toggle"><button class="chart-toggle-btn' + (chartMode === 'daily' ? ' active' : '') + '" id="chart-daily">Daily</button><button class="chart-toggle-btn' + (chartMode === 'cumulative' ? ' active' : '') + '" id="chart-cumulative">Cumulative</button></div></div><canvas id="chart" height="180"></canvas></div>';
          setTimeout(() => renderChart(state.completionLog || []), 0);
        }
      },
      { id: 'chart-heatmap', label: '28-Day Heatmap', type: 'full', icon: '\uD83D\uDFE9',
        render: (el) => {
          const activeHabits = (state.habits || []).filter(h => !h.archived);
          if (!activeHabits.length) { el.innerHTML = '<div class="chart-container" style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px">No active habits for heatmap</div>'; return; }
          el.innerHTML = '<div class="chart-container"><div class="chart-title" style="margin-bottom:8px">28-Day Heatmap</div>' + buildHeatmapHtml(activeHabits) + '</div>';
        }
      },
      { id: 'chart-habit-bars', label: 'Habit Completion Bars', type: 'full', icon: '\uD83D\uDCCA',
        render: (el) => {
          const activeHabits = (state.habits || []).filter(h => !h.archived);
          if (!activeHabits.length) { el.innerHTML = '<div class="chart-container" style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px">No active habits for bars</div>'; return; }
          let html = '<div class="chart-container"><div class="chart-title" style="margin-bottom:8px">Avg Weekly Completion</div>';
          activeHabits.forEach(h => {
            const pct = getAvgWeeklyCompletion(h.id);
            const streak = getHabitStreak(h.id);
            const emoji = getHabitEmoji(h.name);
            html += '<div class="habit-bar-row"><span class="habit-bar-label" title="' + escapeHtml(h.name) + '">' + emoji + ' ' + escapeHtml(h.name) + '</span><div class="habit-bar-track"><div class="habit-bar-fill" style="width:' + pct + '%"></div></div><span class="habit-bar-pct">' + pct + '%</span><span class="habit-bar-streak">\uD83D\uDD25 ' + streak + '</span></div>';
          });
          html += '</div>';
          el.innerHTML = html;
        }
      }
    ];

    function getWidgetById(id) {
      return DASHBOARD_WIDGETS.find(w => w.id === id);
    }

    function getActiveWidgets() {
      if (state.dashboardConfig && state.dashboardConfig.widgets) {
        return state.dashboardConfig.widgets;
      }
      return DEFAULT_WIDGETS;
    }

    // --- Dashboard ---
    function renderDashboard() {
      const container = document.getElementById('dashboard-container');
      // Remove old widgets, preserve config btn + panel
      container.querySelectorAll('.dashboard-widget').forEach(el => el.remove());

      const widgetIds = getActiveWidgets();

      widgetIds.forEach(id => {
        const w = getWidgetById(id);
        if (!w) return;

        if (w.type === 'stat') {
          const wrapper = document.createElement('div');
          wrapper.className = 'dashboard-widget';
          wrapper.setAttribute('draggable', 'true');
          wrapper.dataset.widgetId = id;
          const card = document.createElement('div');
          card.className = 'stat-card';
          w.render(card);
          wrapper.appendChild(card);
          container.appendChild(wrapper);
        } else {
          const wrapper = document.createElement('div');
          wrapper.className = 'dashboard-widget dashboard-widget-full';
          wrapper.setAttribute('draggable', 'true');
          wrapper.dataset.widgetId = id;
          w.render(wrapper);
          container.appendChild(wrapper);
        }
      });

      // Attach drag-and-drop
      attachDashboardDragDrop();
    }

    // --- Dashboard drag-and-drop ---
    let dashDragSource = null;

    function attachDashboardDragDrop() {
      const container = document.getElementById('dashboard-container');
      const widgets = container.querySelectorAll('.dashboard-widget');

      widgets.forEach(widget => {
        widget.addEventListener('dragstart', (e) => {
          dashDragSource = widget;
          widget.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', 'dashboard-widget');
        });

        widget.addEventListener('dragend', () => {
          widget.classList.remove('dragging');
          dashDragSource = null;
          // Clear all drag-over classes
          container.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });
        });

        widget.addEventListener('dragover', (e) => {
          if (!dashDragSource || dashDragSource === widget) return;
          const data = e.dataTransfer.types.includes('text/plain');
          if (!data) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const rect = widget.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          widget.classList.remove('drag-over-top', 'drag-over-bottom');
          if (e.clientY < midY) {
            widget.classList.add('drag-over-top');
          } else {
            widget.classList.add('drag-over-bottom');
          }
        });

        widget.addEventListener('dragleave', () => {
          widget.classList.remove('drag-over-top', 'drag-over-bottom');
        });

        widget.addEventListener('drop', (e) => {
          e.preventDefault();
          if (!dashDragSource || dashDragSource === widget) return;
          widget.classList.remove('drag-over-top', 'drag-over-bottom');

          const widgetIds = getActiveWidgets().slice();
          const srcId = dashDragSource.dataset.widgetId;
          const tgtId = widget.dataset.widgetId;

          // Remove source from array
          const srcIdx = widgetIds.indexOf(srcId);
          if (srcIdx === -1) return;
          widgetIds.splice(srcIdx, 1);

          // Find insertion point
          const rect = widget.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          const insertBefore = e.clientY < midY;

          const tgtIdx = widgetIds.indexOf(tgtId);
          const insertIdx = insertBefore ? tgtIdx : tgtIdx + 1;

          widgetIds.splice(insertIdx, 0, srcId);

          if (!state.dashboardConfig) state.dashboardConfig = {};
          state.dashboardConfig.widgets = widgetIds;
          scheduleSave();
          renderDashboard();
        });
      });
    }

    // --- Dashboard Config Panel ---
    function openDashboardConfig() {
      const panel = document.getElementById('dashboard-config-panel');
      const list = document.getElementById('dashboard-config-list');
      const activeIds = getActiveWidgets();

      let html = '';
      DASHBOARD_WIDGETS.forEach(w => {
        const checked = activeIds.includes(w.id) ? ' checked' : '';
        html += '<label class="dashboard-config-item"><input type="checkbox" data-widget-id="' + w.id + '"' + checked + '><span class="cfg-icon">' + w.icon + '</span><span class="cfg-label">' + w.label + '</span></label>';
      });
      list.innerHTML = html;
      panel.classList.remove('hidden');
    }

    function closeDashboardConfig() {
      document.getElementById('dashboard-config-panel').classList.add('hidden');
      scheduleSave();
      renderDashboard();
    }

    // Delegated handler for dashboard config checkboxes
    document.getElementById('dashboard-config-list').addEventListener('change', (e) => {
      const cb = e.target;
      if (cb.type !== 'checkbox' || !cb.dataset.widgetId) return;
      const id = cb.dataset.widgetId;
      let widgets = getActiveWidgets().slice();
      if (cb.checked) {
        if (!widgets.includes(id)) widgets.push(id);
      } else {
        widgets = widgets.filter(wid => wid !== id);
      }
      if (!state.dashboardConfig) state.dashboardConfig = {};
      state.dashboardConfig.widgets = widgets;
    });

    document.getElementById('dashboard-config-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      const panel = document.getElementById('dashboard-config-panel');
      if (panel.classList.contains('hidden')) {
        // Position panel below the gear button
        const btnRect = e.currentTarget.getBoundingClientRect();
        panel.style.top = (btnRect.bottom + 4) + 'px';
        panel.style.right = (window.innerWidth - btnRect.right) + 'px';
        openDashboardConfig();
      } else {
        closeDashboardConfig();
      }
    });

    document.getElementById('dashboard-config-done').addEventListener('click', (e) => {
      e.stopPropagation();
      closeDashboardConfig();
    });

    // Close config panel when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('dashboard-config-panel');
      if (!panel.classList.contains('hidden') && !e.target.closest('#dashboard-config-panel') && !e.target.closest('#dashboard-config-btn')) {
        closeDashboardConfig();
      }
    });

    function renderChart(log) {
      const canvas = document.getElementById('chart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.parentElement.getBoundingClientRect();
      const w = rect.width - 28;
      const h = 180;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, w, h);

      // Build daily counts for last 14 days
      const days = [];
      const today = new Date();
      for (let i = 13; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        days.push(toDateStr(d));
      }

      const proCounts = {};
      const perCounts = {};
      days.forEach(d => { proCounts[d] = 0; perCounts[d] = 0; });
      log.forEach(entry => {
        if (proCounts[entry.date] !== undefined && entry.category === 'professional') proCounts[entry.date]++;
        if (perCounts[entry.date] !== undefined && entry.category === 'personal') perCounts[entry.date]++;
      });

      // For cumulative mode, also count all completions before the 14-day window
      let proRunning = 0;
      let perRunning = 0;
      if (chartMode === 'cumulative') {
        const firstDay = days[0];
        log.forEach(entry => {
          if (entry.date < firstDay) {
            if (entry.category === 'professional') proRunning++;
            else if (entry.category === 'personal') perRunning++;
          }
        });
      }

      // Build display values
      const proDisplay = [];
      const perDisplay = [];
      if (chartMode === 'cumulative') {
        days.forEach(d => {
          proRunning += proCounts[d];
          perRunning += perCounts[d];
          proDisplay.push(proRunning);
          perDisplay.push(perRunning);
        });
      } else {
        days.forEach(d => {
          proDisplay.push(proCounts[d]);
          perDisplay.push(perCounts[d]);
        });
      }

      const maxVal = Math.max(1, ...proDisplay.map((v, i) => v + perDisplay[i]));
      const chartH = h - 30;
      const originX = 30;
      const originY = h - 20;

      // Grid lines
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= 4; i++) {
        const y = originY - (chartH / 4) * i;
        ctx.beginPath();
        ctx.moveTo(originX, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      // Y-axis labels
      ctx.fillStyle = '#5a5c74';
      ctx.font = '10px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 4; i++) {
        const val = Math.round((maxVal / 4) * i);
        const y = originY - (chartH / 4) * i;
        ctx.fillText(val, originX - 4, y + 3);
      }

      if (chartMode === 'cumulative') {
        // Line chart for cumulative
        const barAreaW = w - 40;
        const step = barAreaW / (days.length - 1);

        // Total fill (area under curve)
        ctx.beginPath();
        ctx.moveTo(originX, originY);
        days.forEach((d, i) => {
          const x = originX + step * i;
          const totalVal = proDisplay[i] + perDisplay[i];
          const y = originY - (totalVal / maxVal) * chartH;
          ctx.lineTo(x, y);
        });
        ctx.lineTo(originX + step * (days.length - 1), originY);
        ctx.closePath();
        ctx.fillStyle = 'rgba(180, 142, 255, 0.06)';
        ctx.fill();

        // Professional line
        ctx.beginPath();
        ctx.strokeStyle = '#5b9cf5';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        days.forEach((d, i) => {
          const x = originX + step * i;
          const y = originY - (proDisplay[i] / maxVal) * chartH;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Personal line
        ctx.beginPath();
        ctx.strokeStyle = '#6dd4a0';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        days.forEach((d, i) => {
          const x = originX + step * i;
          const y = originY - (perDisplay[i] / maxVal) * chartH;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Dots on lines
        days.forEach((d, i) => {
          const x = originX + step * i;
          // Pro dot
          const yPro = originY - (proDisplay[i] / maxVal) * chartH;
          ctx.fillStyle = '#5b9cf5';
          ctx.beginPath();
          ctx.arc(x, yPro, 3, 0, Math.PI * 2);
          ctx.fill();
          // Per dot
          const yPer = originY - (perDisplay[i] / maxVal) * chartH;
          ctx.fillStyle = '#6dd4a0';
          ctx.beginPath();
          ctx.arc(x, yPer, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        // Date labels
        days.forEach((d, i) => {
          if (i % 2 === 0 || days.length <= 7) {
            const x = originX + step * i;
            ctx.fillStyle = '#5a5c74';
            ctx.font = '9px Segoe UI, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(d.slice(5), x, originY + 12);
          }
        });

      } else {
        // Bar chart for daily
        const barAreaW = w - 40;
        const barW = Math.max(4, (barAreaW / days.length) - 6);

        days.forEach((d, i) => {
          const x = originX + (barAreaW / days.length) * i + 3;
          const proH = (proDisplay[i] / maxVal) * chartH;
          const perH = (perDisplay[i] / maxVal) * chartH;
          const totalH = proH + perH;

          if (proH > 0) {
            ctx.fillStyle = '#5b9cf5';
            ctx.beginPath();
            ctx.roundRect(x, originY - totalH, barW, proH, [3, 3, 0, 0]);
            ctx.fill();
          }

          if (perH > 0) {
            ctx.fillStyle = '#6dd4a0';
            ctx.beginPath();
            ctx.roundRect(x, originY - perH, barW, perH, [3, 3, 0, 0]);
            ctx.fill();
          }

          if (proH === 0 && perH === 0) {
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            ctx.beginPath();
            ctx.roundRect(x, originY - 3, barW, 3, [2, 2, 0, 0]);
            ctx.fill();
          }

          if (i % 2 === 0 || days.length <= 7) {
            ctx.fillStyle = '#5a5c74';
            ctx.font = '9px Segoe UI, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(d.slice(5), x + barW / 2, originY + 12);
          }
        });
      }
    }

    // --- Window controls ---
    document.getElementById('btn-min').addEventListener('click', () => window.api.minimize());
    document.getElementById('btn-close').addEventListener('click', () => window.api.close());

    // --- Onboarding ---
    document.getElementById('onboard-go').addEventListener('click', () => {
      const name = document.getElementById('onboard-name').value.trim();
      if (!name) {
        document.getElementById('onboard-error').textContent = 'Please enter your name.';
        return;
      }
      const color = document.getElementById('onboard-color').value;
      state.preferences = { name, color };
      applyPreferences(state.preferences);
      scheduleSave();
      document.getElementById('onboarding').classList.add('hidden');
    });

    document.getElementById('onboard-name').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('onboard-go').click();
    });

    // --- Habit Tracker ---

    function getWeekDays(offset) {
      const now = new Date();
      const day = now.getDay(); // 0=Sun
      const mondayOffset = day === 0 ? -6 : 1 - day;
      const monday = new Date(now);
      monday.setDate(now.getDate() + mondayOffset + (offset * 7));
      const days = [];
      for (let i = 0; i < 7; i++) {
        const d = new Date(monday);
        d.setDate(monday.getDate() + i);
        days.push(toDateStr(d));
      }
      return days;
    }

    const DAY_NAMES = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    function isHabitScheduled(habit, dayOfWeek) {
      // dayOfWeek: 0=Mon, 1=Tue, ..., 6=Sun
      switch (habit.frequency) {
        case 'daily': return true;
        case 'weekdays': case '5x_week': return dayOfWeek < 5;
        case 'weekends': return dayOfWeek >= 5;
        case '3x_week': return [0, 2, 4].includes(dayOfWeek); // Mon, Wed, Fri
        case '2x_week': return [1, 3].includes(dayOfWeek); // Tue, Thu
        case '1x_week': return dayOfWeek === 2; // Wed
        case '4x_week': return [0, 1, 3, 4].includes(dayOfWeek); // Mon, Tue, Thu, Fri
        default: return true;
      }
    }

    function getEffectiveSchedule(habit, weekDays) {
      const base = DAY_NAMES.map((_, i) => isHabitScheduled(habit, i));
      const count = base.filter(Boolean).length;
      if (count >= 6) return base; // daily  not movable
      const weekKey = weekDays[0];
      for (let from = 0; from < 7; from++) {
        const mk = 'move:' + habit.id + ':' + weekKey + ':' + from;
        if (state.habitLog[mk] !== undefined) {
          const to = state.habitLog[mk];
          if (base[from] && !base[to]) {
            base[from] = false;
            base[to] = true;
          }
        }
      }
      return base;
    }

    function isHabitMovable(habit) {
      const count = DAY_NAMES.filter((_, i) => isHabitScheduled(habit, i)).length;
      return count >= 1 && count <= 5;
    }

    function toggleHabitDay(habitId, dateStr) {
      const key = habitId + ':' + dateStr;
      if (state.habitLog[key]) {
        delete state.habitLog[key];
      } else {
        state.habitLog[key] = true;
      }
      scheduleSave();
    }

    // All-habits-complete day streak
    let _dayStreakCache = { ts: 0, val: 0 };
    function getDayStreak() {
      const now = Date.now();
      if (now - _dayStreakCache.ts < 1000) return _dayStreakCache.val;
      const active = (state.habits || []).filter(h => !h.archived);
      if (!active.length) return (_dayStreakCache = { ts: now, val: 0 }).val;
      let streak = 0;
      const d = new Date();
      for (let i = 0; i < 365; i++) {
        const ds = toDateStr(d);
        const dow = d.getDay();
        const dayOfWeek = dow === 0 ? 6 : dow - 1;
        let anyScheduled = false, allDone = true;
        for (const h of active) {
          if (isHabitScheduled(h, dayOfWeek)) {
            anyScheduled = true;
            if (!state.habitLog[h.id + ':' + ds]) { allDone = false; break; }
          }
        }
        if (anyScheduled && allDone) {
          streak++;
        } else if (anyScheduled && !allDone) {
          if (i === 0) { d.setDate(d.getDate() - 1); continue; } // skip today if incomplete
          break;
        }
        d.setDate(d.getDate() - 1);
      }
      _dayStreakCache = { ts: now, val: streak };
      return streak;
    }

    function isTodayAllComplete() {
      const active = (state.habits || []).filter(h => !h.archived);
      const today = todayStr();
      const dow = new Date().getDay();
      const dayOfWeek = dow === 0 ? 6 : dow - 1;
      for (const h of active) {
        if (isHabitScheduled(h, dayOfWeek)) {
          if (!state.habitLog[h.id + ':' + today]) return false;
        }
      }
      return active.length > 0;
    }

    // Auto-emoji for habits based on name keywords
    const HABIT_EMOJI_GROUPS = [
      { emoji: '\uD83C\uDFCB\uFE0F', keywords: ['exercise', 'train', 'weights', 'weight', 'lift', 'push up', 'pushup', 'pull up', 'pullup', 'squat', 'gym', 'barbell', 'dumbbell', 'workout', 'bench', 'run', 'running', 'sprint', 'jog', 'cardio', 'sport', 'swim', 'cycling', 'bike', 'hike', 'walk', 'plank', 'crunch', 'deadlift', 'press', 'curl', 'rowing', 'jump', 'burpee', 'crossfit', 'hiit', 'fitness'] },
      { emoji: '\uD83D\uDCA7', keywords: ['water', 'drink', 'hydrate', 'hydration', 'liquid', 'litre', 'liter', 'fluid', 'h2o', 'sip', 'glass', 'bottle', 'oz', 'sparkling', 'electrolyte', 'intake'] },
      { emoji: '\uD83E\uDDD8', keywords: ['meditat', 'breath', 'yoga', 'stretch', 'mindful', 'calm', 'relax', 'zen', 'inhale', 'exhale', 'pranayama', 'flexibility', 'pose', 'mantra', 'gratitude', 'prayer', 'reflect', 'peace', 'stillness'] },
      { emoji: '\uD83D\uDCDA', keywords: ['read', 'book', 'study', 'learn', 'journal', 'write', 'notes', 'review', 'homework', 'course', 'lesson', 'practice', 'chapter', 'page', 'article', 'podcast', 'lecture', 'skill', 'tutorial'] },
      { emoji: '\uD83C\uDF4E', keywords: ['eat', 'diet', 'food', 'meal', 'cook', 'nutrition', 'vegetable', 'fruit', 'healthy', 'calorie', 'protein', 'vitamin', 'supplement', 'prep', 'salad', 'sugar', 'fast', 'fasting', 'snack'] },
      { emoji: '\uD83D\uDE34', keywords: ['sleep', 'bed', 'rest', 'nap', 'wake', 'morning', 'night', 'routine', 'alarm', 'early', 'screen', 'wind down', 'pillow', 'dream', 'insomnia', 'circadian'] },
      { emoji: '\uD83E\uDDF9', keywords: ['clean', 'tidy', 'vacuum', 'mop', 'sweep', 'dust', 'laundry', 'wash', 'dishes', 'declutter', 'organize', 'scrub', 'wipe', 'trash', 'bin', 'chore', 'spotless'] }
    ];
    const FALLBACK_EMOJI = '\u2B50';

    const _emojiCache = {};
    function getHabitEmoji(name) {
      if (_emojiCache[name] !== undefined) return _emojiCache[name];
      const lower = name.toLowerCase();
      for (const group of HABIT_EMOJI_GROUPS) {
        for (const kw of group.keywords) {
          if (lower.includes(kw)) return (_emojiCache[name] = group.emoji);
        }
      }
      return (_emojiCache[name] = FALLBACK_EMOJI);
    }

    function buildHeatmapHtml(activeHabits) {
      let html = '<div style="display:flex;gap:2px;margin-bottom:4px">';
      DAY_NAMES.forEach(n => { html += '<div class="habit-heatmap-label" style="flex:1">' + n.charAt(0) + '</div>'; });
      html += '</div><div class="habit-heatmap">';
      const heatDays = [];
      const heatEnd = new Date();
      const heatDow = heatEnd.getDay();
      const heatMondayOff = heatDow === 0 ? -6 : 1 - heatDow;
      const heatStart = new Date(heatEnd);
      heatStart.setDate(heatEnd.getDate() + heatMondayOff - 21);
      for (let i = 0; i < 28; i++) { const dd = new Date(heatStart); dd.setDate(heatStart.getDate() + i); heatDays.push(toDateStr(dd)); }
      heatDays.forEach(dateStr => {
        const dd = new Date(dateStr + 'T00:00:00');
        const dow = dd.getDay();
        const dayOfWeek = dow === 0 ? 6 : dow - 1;
        let scheduled = 0, completed = 0;
        activeHabits.forEach(h => {
          if (isHabitScheduled(h, dayOfWeek)) { scheduled++; if (state.habitLog[h.id + ':' + dateStr]) completed++; }
        });
        const ratio = scheduled > 0 ? completed / scheduled : 0;
        let bg;
        if (ratio === 0) bg = 'var(--bg-overlay)';
        else if (ratio < 0.5) bg = 'rgba(109, 212, 160, 0.2)';
        else if (ratio < 1) bg = 'rgba(109, 212, 160, 0.45)';
        else bg = 'rgba(109, 212, 160, 0.75)';
        html += '<div class="habit-heatmap-cell" style="background:' + bg + '" title="' + dateStr + ': ' + completed + '/' + scheduled + '"></div>';
      });
      html += '</div>';
      return html;
    }

    function getHabitStreak(habitId) {
      const habit = state.habits.find(h => h.id === habitId);
      if (!habit) return 0;
      let streak = 0;
      const d = new Date();
      for (let i = 0; i < 365; i++) {
        const dateStr = toDateStr(d);
        const dow = d.getDay();
        const dayOfWeek = dow === 0 ? 6 : dow - 1; // convert to 0=Mon
        if (isHabitScheduled(habit, dayOfWeek)) {
          if (state.habitLog[habitId + ':' + dateStr]) {
            streak++;
          } else {
            // If it's today and not yet checked, skip (don't break streak)
            if (i === 0) { d.setDate(d.getDate() - 1); continue; }
            break;
          }
        }
        d.setDate(d.getDate() - 1);
      }
      return streak;
    }

    function getWeeklyCompletion(habitId, weekDays) {
      const habit = state.habits.find(h => h.id === habitId);
      if (!habit) return { completed: 0, scheduled: 0, percent: 0 };
      const effectiveSched = getEffectiveSchedule(habit, weekDays);
      let completed = 0, scheduled = 0;
      weekDays.forEach((dateStr, i) => {
        if (effectiveSched[i]) {
          scheduled++;
          if (state.habitLog[habitId + ':' + dateStr]) completed++;
        }
      });
      return { completed, scheduled, percent: scheduled > 0 ? Math.round((completed / scheduled) * 100) : 0 };
    }

    function getAvgWeeklyCompletion(habitId) {
      const habit = state.habits.find(h => h.id === habitId);
      if (!habit) return 0;
      // Walk back week by week from current week to creation week
      const createdAt = new Date((habit.createdAt || todayStr()) + 'T00:00:00');
      let weekPcts = [];
      for (let offset = 0; offset >= -52; offset--) {
        const wDays = getWeekDays(offset);
        const weekStart = new Date(wDays[0] + 'T00:00:00');
        if (weekStart < createdAt && offset !== 0) break;
        let scheduled = 0, completed = 0;
        wDays.forEach((dateStr, i) => {
          if (isHabitScheduled(habit, i)) {
            scheduled++;
            if (state.habitLog[habitId + ':' + dateStr]) completed++;
          }
        });
        if (scheduled > 0) weekPcts.push(Math.round((completed / scheduled) * 100));
      }
      if (!weekPcts.length) return 0;
      return Math.round(weekPcts.reduce((a, b) => a + b, 0) / weekPcts.length);
    }

    function getXPLevel() {
      let checks = 0;
      for (const key in state.habitLog) { if (key.charAt(0) !== 'm') checks++; }
      const total = checks * 10;
      const level = Math.floor(total / 500) + 1;
      const xpInLevel = total % 500;
      return { total, level, xpInLevel, xpNeeded: 500 };
    }

    function getFrequencyLabel(freq) {
      const labels = {
        daily: 'Daily', weekdays: 'Weekdays', weekends: 'Weekends',
        '5x_week': '5x/wk', '4x_week': '4x/wk', '3x_week': '3x/wk', '2x_week': '2x/wk', '1x_week': '1x/wk'
      };
      return labels[freq] || freq;
    }

    function formatWeekLabel(weekDays) {
      const start = new Date(weekDays[0] + 'T00:00:00');
      const end = new Date(weekDays[6] + 'T00:00:00');
      const opts = { month: 'short', day: 'numeric' };
      return start.toLocaleDateString('en-US', opts) + ' \u2013 ' + end.toLocaleDateString('en-US', opts);
    }

    // --- Render: Habit Tracker Grid ---
    function renderHabitTracker() {
      const weekDays = getWeekDays(habitWeekOffset);
      const today = todayStr();
      const grid = document.getElementById('habit-grid');
      const statsRow = document.getElementById('habit-stats-row');

      // Week label
      document.getElementById('habit-week-label').textContent = formatWeekLabel(weekDays);
      document.getElementById('habit-next-week').disabled = habitWeekOffset >= 0;

      const activeHabits = (state.habits || []).filter(h => !h.archived);

      if (!activeHabits.length) {
        grid.innerHTML = '<div class="habit-empty">No habits yet<div class="habit-empty-hint">Switch to "Input & Performance" to add your first habit</div></div>';
        statsRow.innerHTML = '';
        return;
      }

      // Build table
      let html = '<table class="habit-grid-table"><thead><tr><th></th>';
      weekDays.forEach((dateStr, i) => {
        const isToday = dateStr === today;
        html += '<th' + (isToday ? ' class="today-col"' : '') + '>' + DAY_NAMES[i] + '<br><span style="font-size:9px;font-weight:400">' + dateStr.slice(8) + '</span></th>';
      });
      html += '</tr></thead><tbody>';

      activeHabits.forEach(habit => {
        const effectiveSched = getEffectiveSchedule(habit, weekDays);
        const movable = isHabitMovable(habit);
        html += '<tr><td title="' + escapeHtml(habit.name) + '">' + getHabitEmoji(habit.name) + ' ' + escapeHtml(habit.name) + '</td>';
        weekDays.forEach((dateStr, i) => {
          const scheduled = effectiveSched[i];
          const checked = state.habitLog[habit.id + ':' + dateStr];
          const tdClass = dateStr === today ? ' class="today"' : '';
          if (scheduled) {
            html += '<td' + tdClass + '><div class="habit-cell' + (checked ? ' checked' : '') + '"' + (movable ? ' draggable="true" data-day="' + i + '"' : '') + ' data-habit="' + habit.id + '" data-date="' + dateStr + '">' + (checked ? '\u2713' : '') + '</div></td>';
          } else if (movable) {
            html += '<td' + tdClass + '><div class="habit-drop-target" data-habit="' + habit.id + '" data-date="' + dateStr + '" data-day="' + i + '"></div></td>';
          } else {
            html += '<td' + tdClass + '></td>';
          }
        });
        html += '</tr>';
      });

      html += '</tbody></table>';
      grid.innerHTML = html;

      // Click handlers for cells
      grid.querySelectorAll('.habit-cell').forEach(cell => {
        cell.addEventListener('click', () => {
          toggleHabitDay(cell.dataset.habit, cell.dataset.date);
          renderHabitTracker();
        });
      });

      // Drag-and-drop for movable habit slots
      grid.querySelectorAll('.habit-cell[draggable="true"]').forEach(cell => {
        cell.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', cell.dataset.habit + '|' + cell.dataset.day + '|' + cell.dataset.date);
          cell.style.opacity = '0.4';
        });
        cell.addEventListener('dragend', () => { cell.style.opacity = ''; });
      });

      grid.querySelectorAll('.habit-drop-target').forEach(target => {
        target.addEventListener('dragover', (e) => {
          const data = e.dataTransfer.types.includes('text/plain');
          if (!data) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          target.classList.add('drag-over');
        });
        target.addEventListener('dragleave', () => { target.classList.remove('drag-over'); });
        target.addEventListener('drop', (e) => {
          e.preventDefault();
          target.classList.remove('drag-over');
          const parts = e.dataTransfer.getData('text/plain').split('|');
          const srcHabitId = parts[0];
          const srcDay = parseInt(parts[1]);
          const srcDate = parts[2];
          const tgtHabitId = target.dataset.habit;
          const tgtDay = parseInt(target.dataset.day);
          const tgtDate = target.dataset.date;

          if (srcHabitId !== tgtHabitId) return;
          const habit = state.habits.find(h => h.id === srcHabitId);
          if (!habit) return;
          const weekKey = weekDays[0];

          // Get current effective layout, apply the drag, then diff against base
          const current = getEffectiveSchedule(habit, weekDays);
          current[srcDay] = false;
          current[tgtDay] = true;

          // Clear all existing move keys for this habit+week
          for (let f = 0; f < 7; f++) {
            delete state.habitLog['move:' + srcHabitId + ':' + weekKey + ':' + f];
          }

          // Write fresh move keys: for each base day that ended up somewhere else
          const base = DAY_NAMES.map((_, i) => isHabitScheduled(habit, i));
          const baseDays = base.map((v, i) => v ? i : -1).filter(i => i >= 0);
          const currentDays = current.map((v, i) => v ? i : -1).filter(i => i >= 0);

          // Match base slots to current slots by position (preserve order)
          baseDays.sort((a, b) => a - b);
          currentDays.sort((a, b) => a - b);
          for (let j = 0; j < baseDays.length; j++) {
            if (baseDays[j] !== currentDays[j]) {
              state.habitLog['move:' + srcHabitId + ':' + weekKey + ':' + baseDays[j]] = currentDays[j];
            }
          }

          // Migrate check data
          const srcCheckKey = srcHabitId + ':' + srcDate;
          const tgtCheckKey = srcHabitId + ':' + tgtDate;
          if (state.habitLog[srcCheckKey]) {
            state.habitLog[tgtCheckKey] = true;
            delete state.habitLog[srcCheckKey];
          }

          scheduleSave();
          renderHabitTracker();
        });
      });

      // Stats row
      let weekCompleted = 0, weekScheduled = 0;
      activeHabits.forEach(h => {
        const wc = getWeeklyCompletion(h.id, weekDays);
        weekCompleted += wc.completed;
        weekScheduled += wc.scheduled;
      });
      const weekPct = weekScheduled > 0 ? Math.round((weekCompleted / weekScheduled) * 100) : 0;
      const xp = getXPLevel();

      // All-habits-complete day streak
      const dayStreak = getDayStreak();
      const streakMilestone = [7, 14, 30, 60, 100].includes(dayStreak);

      // Streak at risk: past 7 PM, today not all complete, but have an active streak
      const hour = new Date().getHours();
      const atRisk = dayStreak > 0 && hour >= 19 && !isTodayAllComplete();

      // Ring SVG for weekly %
      const ringColor = weekPct >= 80 ? 'var(--green)' : weekPct >= 40 ? 'var(--yellow)' : 'var(--red)';
      const circumference = 2 * Math.PI * 22;
      const dashOffset = circumference - (weekPct / 100) * circumference;
      const ringSvg = '<svg width="54" height="54" viewBox="0 0 54 54"><circle cx="27" cy="27" r="22" fill="none" stroke="var(--bg-overlay)" stroke-width="4"/><circle cx="27" cy="27" r="22" fill="none" stroke="' + ringColor + '" stroke-width="4" stroke-linecap="round" stroke-dasharray="' + circumference + '" stroke-dashoffset="' + dashOffset + '" transform="rotate(-90 27 27)" style="transition:stroke-dashoffset 0.4s"/></svg>';

      statsRow.innerHTML =
        '<div class="habit-stat-card' + (streakMilestone ? ' milestone' : '') + (atRisk ? ' at-risk' : '') + '">' +
          '<div class="habit-stat-icon">' + (atRisk ? '\u26A0\uFE0F' : '\uD83D\uDD25') + '</div>' +
          '<div class="habit-stat-value">' + dayStreak + '</div>' +
          '<div class="habit-stat-label">' + (atRisk ? 'Streak at Risk' : 'Day Streak') + '</div>' +
        '</div>' +
        '<div class="habit-stat-card">' +
          '<div class="habit-ring-container">' + ringSvg + '<span class="habit-ring-text">' + weekPct + '%</span></div>' +
          '<div class="habit-stat-label">This Week</div>' +
        '</div>' +
        '<div class="habit-stat-card">' +
          '<div class="habit-stat-icon">\u2B50</div>' +
          '<div class="habit-stat-value blue-val">Lv ' + xp.level + '</div>' +
          '<div class="habit-stat-label">' + xp.xpInLevel + '/' + xp.xpNeeded + ' XP</div>' +
        '</div>';
    }

    // --- Render: Habit Manage + Performance ---
    function renderHabitManage() {
      const list = document.getElementById('habit-manage-list');
      const perf = document.getElementById('habit-performance');
      const habits = state.habits || [];

      // Habit list
      let listHtml = '';
      habits.forEach((habit, idx) => {
        const active = !habit.archived;
        listHtml += '<div class="habit-manage-item">' +
          '<span class="habit-manage-name' + (active ? '' : ' inactive') + '">' + getHabitEmoji(habit.name) + ' ' + escapeHtml(habit.name) + '</span>' +
          '<span class="habit-freq-badge">' + getFrequencyLabel(habit.frequency) + '</span>' +
          '<button class="habit-manage-btn toggle-btn ' + (active ? 'is-active' : 'is-inactive') + '" data-idx="' + idx + '" title="' + (active ? 'Deactivate' : 'Activate') + '">' + (active ? 'Active' : 'Inactive') + '</button>' +
          '<button class="habit-manage-btn delete-btn" data-idx="' + idx + '" title="Delete">\u00D7</button>' +
        '</div>';
      });

      if (!habits.length) {
        listHtml = '<div class="habit-empty">Add your first habit above</div>';
      }

      list.innerHTML = listHtml;

      // Event: activate/deactivate
      list.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const i = parseInt(btn.dataset.idx);
          state.habits[i].archived = !state.habits[i].archived;
          scheduleSave();
          renderHabitManage();
        });
      });

      // Event: delete
      list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const i = parseInt(btn.dataset.idx);
          const habitId = state.habits[i].id;
          state.habits.splice(i, 1);
          // Clean up log entries and move keys for deleted habit
          Object.keys(state.habitLog).forEach(key => {
            if (key.startsWith(habitId + ':') || key.includes(':' + habitId + ':')) delete state.habitLog[key];
          });
          scheduleSave();
          renderHabitManage();
        });
      });

      // Performance section
      const activeHabits = habits.filter(h => !h.archived);
      if (!activeHabits.length) {
        perf.innerHTML = '';
        return;
      }

      let perfHtml = '<div class="habit-perf-title">Avg Weekly Completion</div>';

      // Per-habit average weekly completion bars
      activeHabits.forEach(h => {
        const pct = getAvgWeeklyCompletion(h.id);
        const streak = getHabitStreak(h.id);
        const emoji = getHabitEmoji(h.name);
        perfHtml += '<div class="habit-bar-row">' +
          '<span class="habit-bar-label" title="' + escapeHtml(h.name) + '">' + emoji + ' ' + escapeHtml(h.name) + '</span>' +
          '<div class="habit-bar-track"><div class="habit-bar-fill" style="width:' + pct + '%"></div></div>' +
          '<span class="habit-bar-pct">' + pct + '%</span>' +
          '<span class="habit-bar-streak">\uD83D\uDD25 ' + streak + '</span>' +
        '</div>';
      });

      // XP section
      const xp = getXPLevel();
      perfHtml += '<div class="habit-xp-section">' +
        '<div class="habit-xp-header">' +
          '<span class="habit-xp-level">\u2B50 Level ' + xp.level + '</span>' +
          '<span class="habit-xp-text">' + xp.xpInLevel + ' / ' + xp.xpNeeded + ' XP</span>' +
        '</div>' +
        '<div class="habit-xp-track"><div class="habit-xp-fill" style="width:' + ((xp.xpInLevel / xp.xpNeeded) * 100) + '%"></div></div>' +
      '</div>';

      // 4-week mini heatmap
      perfHtml += '<div style="margin-top:12px"><div class="habit-perf-title">28-Day Heatmap</div>';
      perfHtml += buildHeatmapHtml(activeHabits);
      perfHtml += '</div>';

      perf.innerHTML = perfHtml;
    }

    function renderActiveHabitView() {
      if (activeHabitView === 'tracker') renderHabitTracker();
      else renderHabitManage();
    }

    // --- Habit sub-tab switching ---
    document.getElementById('habit-tab-tracker').addEventListener('click', () => {
      if (activeHabitView === 'tracker') return;
      activeHabitView = 'tracker';
      document.getElementById('habit-tab-tracker').className = 'cat-btn active-habit';
      document.getElementById('habit-tab-manage').className = 'cat-btn';
      document.getElementById('habit-view-tracker').classList.add('active');
      document.getElementById('habit-view-manage').classList.remove('active');
      renderHabitTracker();
    });

    document.getElementById('habit-tab-manage').addEventListener('click', () => {
      if (activeHabitView === 'manage') return;
      activeHabitView = 'manage';
      document.getElementById('habit-tab-manage').className = 'cat-btn active-manage';
      document.getElementById('habit-tab-tracker').className = 'cat-btn';
      document.getElementById('habit-view-manage').classList.add('active');
      document.getElementById('habit-view-tracker').classList.remove('active');
      renderHabitManage();
    });

    // --- Habit week navigation ---
    document.getElementById('habit-prev-week').addEventListener('click', () => {
      habitWeekOffset--;
      renderHabitTracker();
    });
    document.getElementById('habit-next-week').addEventListener('click', () => {
      if (habitWeekOffset < 0) {
        habitWeekOffset++;
        renderHabitTracker();
      }
    });

    // --- Add habit ---
    document.getElementById('habit-name-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const name = e.target.value.trim();
        if (!name) return;
        const freq = document.getElementById('habit-freq-select').value;
        if (!state.habits) state.habits = [];
        state.habits.push({
          id: 'h_' + Date.now(),
          name: name,
          frequency: freq,
          createdAt: todayStr(),
          archived: false
        });
        e.target.value = '';
        scheduleSave();
        renderHabitManage();
      }
    });

    // --- Elastic overscroll (optimised, one bounce per gesture, repeatable) ---
    document.querySelectorAll('.notes-editor, .checklist-items, .dashboard, .habit-grid, .habit-manage-scroll').forEach(el => {
      let locked = false;
      let animating = false;
      let idleTimer = null;

      // Snap-back on transitionend  frame-accurate, no guessing with setTimeout
      el.addEventListener('transitionend', (e) => {
        if (e.propertyName !== 'transform') return;
        if (!el.style.transform || el.style.transform === 'none') {
          el.classList.remove('bounce-back');
          animating = false;
        }
      });

      el.addEventListener('wheel', (e) => {
        const atTop = el.scrollTop <= 0;
        const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
        const overscroll = (atTop && e.deltaY < 0) || (atBottom && e.deltaY > 0);

        // Idle unlock  resets on every wheel event
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => { if (!animating) locked = false; }, 350);

        if (!overscroll) {
          if (!animating) locked = false;
          return;
        }

        e.preventDefault();
        if (locked) return;
        locked = true;
        animating = true;

        // Bounce out
        const dir = e.deltaY < 0 ? 1 : -1;
        el.classList.remove('bounce-back');
        el.classList.add('bounce-out');
        el.style.transform = 'translate3d(0,' + (dir * 30) + 'px,0)';

        // Bounce back after out-transition completes
        setTimeout(() => {
          el.classList.remove('bounce-out');
          el.classList.add('bounce-back');
          el.style.transform = '';
        }, 100);
      }, { passive: false });
    });

    // --- Init ---
    load();
    const quoteIntervalId = setInterval(() => showQuote(true), 60000);
  </script>
</body>
</html>
